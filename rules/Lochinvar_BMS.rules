import org.openhab.core.model.script.ScriptServiceUtil

// ===================================================================================
// HYBRID LOCHINVAR LOGIC (Governor Architecture)
// ===================================================================================

// -----------------------------------------------------------------------------------
// RULE 1: HEARTBEAT & WATCHDOG (Runs every minute)
// -----------------------------------------------------------------------------------
rule "Boiler Heartbeat and Mode Enforcement"
when
    Time cron "0 * * ? * *" 
then
    if (Boiler_Test_Repeat.state == ON) return;
    if (System_Maintenance_Mode.state == ON) return;

    // SAFETY CHECK: LOCKOUT
    val int lockoutCode = if(Boiler_Lockout_Code.state instanceof Number) (Boiler_Lockout_Code.state as Number).intValue else 32767
    
    if (lockoutCode != 32767) {
        logWarn("Boiler.Safety", "HARD LOCKOUT DETECTED (Code " + lockoutCode + "). BMS Control Paused.")
        return;
    }

    // NULL SAFETY CHECK
    if (Boiler_BMS_ENBLE.state == NULL || Boiler_BMS_ENBLE.state == UNDEF) {
        return;
    }

    if (Boiler_BMS_ENBLE.state == ON) {
        // === BMS MODE ===
        // Always enforce Control Mode 5 (BMS Rate)
        Lochinvar_40001_Control_Mode.sendCommand(5)
        
        // Safety: Ensure Physical CFH Relays are OFF
        if (CFH1.state == ON) CFH1.sendCommand(OFF)
        if (CFH2.state == ON) CFH2.sendCommand(OFF)
    } 
    else if (Boiler_BMS_ENBLE.state == OFF) {
        // === RELAY/LEGACY MODE ===
        Lochinvar_40001_Control_Mode.sendCommand(0)
        
        if (Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) {
            if ((Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue != 0) {
                Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(0)
            }
        }
        
        if (Lochinvar_40003_Rate_Command.state instanceof Number) {
            if ((Lochinvar_40003_Rate_Command.state as Number).intValue != 0) {
                Lochinvar_40003_Rate_Command.sendCommand(0)
            }
        }
    }
end

// -----------------------------------------------------------------------------------
// RULE 2: MAIN FIRING LOOP (Runs every 5 seconds)
// -----------------------------------------------------------------------------------
rule "Hybrid Boiler PID Loop"
when
    Time cron "0/5 * * * * ?"
then
    if (Boiler_Test_Repeat.state == ON) return;
    
    // =======================================================================
    // 1. FETCH SENSORS & MEMORY
    // =======================================================================
    var double mem_pid_integral = 0.0
    if (Boiler_Pid_Integral.state instanceof Number) {
        mem_pid_integral = (Boiler_Pid_Integral.state as Number).doubleValue
    }

    // Fetch Temperatures & Pump Speed - Defaulting to safe values if NULL
    val double supplyTemp  = if(System_Supply_Temp.state instanceof Number) (System_Supply_Temp.state as Number).doubleValue else 140.0
    val double targetTemp  = if(Boiler_Target_Temp.state instanceof Number) (Boiler_Target_Temp.state as Number).doubleValue else 0.0
    val double outletTemp  = if(Boiler_Outlet_Temp.state instanceof Number) (Boiler_Outlet_Temp.state as Number).doubleValue else 140.0
    val double inletTemp   = if(Boiler_Inlet_Temp.state instanceof Number) (Boiler_Inlet_Temp.state as Number).doubleValue else 120.0
    
    // =======================================================================
    // 2. MAINTENANCE MODE INTERCEPT
    // =======================================================================
    if (System_Maintenance_Mode.state == ON) {
        if (mem_pid_integral != 0.0) Boiler_Pid_Integral.postUpdate(0)
        Boiler_PID_Output.postUpdate(0)
        Boiler_Final_Command.postUpdate(0)
        return;
    }
    
    if (Boiler_BMS_ENBLE.state != ON) {
        if (mem_pid_integral != 0.0) Boiler_Pid_Integral.postUpdate(0)
        return;
    }

    // GATHER TUNING
    var double base_Kp = if(Boiler_Kp.state instanceof Number) (Boiler_Kp.state as Number).doubleValue else 3.0
    var double Ki = if(Boiler_Ki.state instanceof Number) (Boiler_Ki.state as Number).doubleValue else 0.15
    
    // PUMP ACTUATION
    var boolean highTempCall = (LRZV.state == ON || GBrZV.state == ON || BMTZV.state == ON || GAZV.state == ON || MRZV.state == ON)
    var boolean lowTempCall = (KITRH.state == ON || DENRH.state == ON || MBaRH.state == ON || MBeRH.state == ON)

    if (highTempCall) { if (SysPump.state != ON) SysPump.sendCommand(ON) } else { if (SysPump.state != OFF) SysPump.sendCommand(OFF) }
    if (lowTempCall) { if (RHP.state != ON) RHP.sendCommand(ON) } else { if (RHP.state != OFF) RHP.sendCommand(OFF) }
    
    // =======================================================================
    // 4. FIRING ARBITRATION LOGIC (Variables Hoisted for OH2.5 Safety)
    // =======================================================================
    var double finalRate = 0.0
    var boolean update_pid_mem = false
    
    // Pre-declare ALL calculation variables to avoid Scope/JvmVoid errors
    var double govOutletLimit = 100.0
    var double govFlowLimit = 100.0
    var double pidRequest = 0.0
    var double safeRate = 0.0
    var double severity = 0.0
    var double flowSeverity = 0.0
    
    // We only fire if not Blocked AND we have a Target > 0
    if (Boiler_Block_Active.state != ON && (highTempCall || lowTempCall) && targetTemp > 0) {
            
        // ----------------------------------------
        // COMPONENT 1: MAIN PID (The "Driver")
        // ----------------------------------------
        var double error = targetTemp - supplyTemp
        var double P = base_Kp * error
        
        // Calculate PID Request
        pidRequest = P + mem_pid_integral
        
        // Clamp PID Request
        if (pidRequest > 100.0) pidRequest = 100.0
        if (pidRequest < 0.0) pidRequest = 0.0
        
        Boiler_PID_Output.postUpdate(pidRequest)

        // ----------------------------------------
        // COMPONENT 2: THE GOVERNORS (The Constraints)
        // ----------------------------------------
        
        // GOVERNOR A: Outlet Temperature Ceiling (170F - 180F)
        // Use constants for clarity
        val double outletMax = 180.0
        val double outletStart = 170.0
        
        if (outletTemp > outletStart) {
            // Explicit OH2.5 Math: Force double precision
            severity = (outletMax - outletTemp) / (outletMax - outletStart)
            govOutletLimit = severity * 100.0
        }
        
        // GOVERNOR B: Delta T Guard (20F - 30F)
        val double dtMax = 30.0
        val double dtStart = 20.0
        var double sysDelta = outletTemp - supplyTemp
        
        if (sysDelta > dtStart) {
             flowSeverity = (dtMax - sysDelta) / (dtMax - dtStart)
             govFlowLimit = flowSeverity * 100.0
        }

        // ----------------------------------------
        // FINAL ARBITRATION (Lowest Value Wins)
        // ----------------------------------------
        safeRate = pidRequest
        
        // Apply Outlet Governor
        if (safeRate > govOutletLimit) safeRate = govOutletLimit
        
        // Apply Flow Governor
        if (safeRate > govFlowLimit) safeRate = govFlowLimit
        
        // Sanity Clamp
        if (safeRate < 0.0) safeRate = 0.0
        
        // ----------------------------------------
        // INTEGRAL MANAGEMENT (Anti-Windup)
        // ----------------------------------------
        // Check if Governors are actively limiting the output
        var boolean governorsActive = (safeRate < pidRequest)
        
        if (!governorsActive) {
            // Standard Integral accumulation
            mem_pid_integral = mem_pid_integral + ((Ki * 0.5) * error)
        } 
        else {
            // Governors Active: Only allow wind-down if we are overshooting (Error < 0)
            if (error < 0 && mem_pid_integral > 0) {
                mem_pid_integral = mem_pid_integral + ((Ki * 0.5) * error) 
            }
        }
        
        // Hard Integral Limits
        if (mem_pid_integral > 50.0) mem_pid_integral = 50.0
        if (mem_pid_integral < -10.0) mem_pid_integral = -10.0
        update_pid_mem = true

        // ----------------------------------------
        // FINAL DEADBAND & OUTPUT
        // ----------------------------------------
        if (safeRate < 15.0) {
            if (safeRate > 8.0) finalRate = 20.0 
            else { 
                finalRate = 0.0
                mem_pid_integral = 0.0
                update_pid_mem = true
            }
        } 
        else {
            finalRate = safeRate
        }
        
        if (finalRate > 100.0) finalRate = 100.0
        
    } // End Active Check
    else {
        // No Call or Blocked
        finalRate = 0.0
        if (Boiler_Block_Active.state == ON) {
            mem_pid_integral = 0.0
            update_pid_mem = true
        }
    }

    // 5. UPDATE MEMORY
    if (update_pid_mem) Boiler_Pid_Integral.postUpdate(mem_pid_integral)

    // 6. MODBUS COMMAND
    Boiler_Final_Command.postUpdate(finalRate)
    
    // Explicit casting for OH2.5 integer conversion
    var int payload = (finalRate).intValue

    // Enable Logic
    var boolean anyCallActive = (highTempCall || lowTempCall)
    var int desiredEnable = if (payload > 0 || anyCallActive) 1 else 0  

    if (Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) {
        if ((Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue != desiredEnable) {
             Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(desiredEnable)
             if (desiredEnable == 1) Thread::sleep(100) 
        }
    }
    
    var int currentRate = -1
    if (Lochinvar_40003_Rate_Command.state instanceof Number) {
        currentRate = (Lochinvar_40003_Rate_Command.state as Number).intValue
    }
    
    if (currentRate != payload) {
        var int currentMode = 0
        if (Lochinvar_40001_Control_Mode.state instanceof Number) {
            currentMode = (Lochinvar_40001_Control_Mode.state as Number).intValue
        }
        
        if (currentMode != 5 && payload > 0) {
             Lochinvar_40001_Control_Mode.sendCommand(5)
             Thread::sleep(100) 
        }
        Lochinvar_40003_Rate_Command.sendCommand(payload)
    }
end

rule "Normalize Boiler State for Grafana"
when
    Item Boiler_Status_Code changed or
    Item Boiler_Blocking changed or
    Item Boiler_Lockout_Code changed
then
    var int graphState = 0
    var int status = if(Boiler_Status_Code.state instanceof Number) (Boiler_Status_Code.state as Number).intValue else 0
    var int block  = if(Boiler_Blocking.state instanceof Number) (Boiler_Blocking.state as Number).intValue else 0
    var int lock   = if(Boiler_Lockout_Code.state instanceof Number) (Boiler_Lockout_Code.state as Number).intValue else 32767

    if (lock != 32767) {
        graphState = -2
    }
    else if (block != 0 && block != 32767) {
        graphState = -1
    }
    else if (status == 19) {
        graphState = 2
    }
    else if (status == 21 || status == 22 || status == 23) {
        graphState = 1
    }
    else {
        graphState = 0
    }

    if (Boiler_Graph_State.state != graphState) {
        Boiler_Graph_State.postUpdate(graphState)
    }
end