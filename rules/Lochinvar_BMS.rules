import org.openhab.core.model.script.ScriptServiceUtil

// ===================================================================================
// HYBRID LOCHINVAR LOGIC (Actuator & Firing Control)
// ===================================================================================

// PID Controller Variables (Firing Loop Only)
var Number pid_integral = 0.0

// -----------------------------------------------------------------------------------
// RULE 1: HEARTBEAT & WATCHDOG (Runs every minute)
// -----------------------------------------------------------------------------------
rule "Boiler Heartbeat and Mode Enforcement"
when
    Time cron "0 * * ? * *" 
then
    if (Boiler_Test_Repeat.state == ON) return;
    if (System_Maintenance_Mode.state == ON) return;

    // SAFETY CHECK: LOCKOUT
    val int lockoutCode = if(Boiler_Lockout_Code.state instanceof Number) (Boiler_Lockout_Code.state as Number).intValue else 32767
    
    if (lockoutCode != 32767) {
        logWarn("Boiler.Safety", "HARD LOCKOUT DETECTED (Code " + lockoutCode + "). BMS Control Paused.")
        return;
    }

    // NULL SAFETY CHECK
    if (Boiler_BMS_ENBLE.state == NULL || Boiler_BMS_ENBLE.state == UNDEF) {
        return;
    }

    if (Boiler_BMS_ENBLE.state == ON) {
        // === BMS MODE ===
        // Only enforce Enable=1 if we are NOT currently blocked by the Shutoff Rule.
        if (Boiler_Block_Active.state != ON) {
            if (Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) {
                if ((Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue != 1) {
                     Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(1)
                }
            }
        }
        
        // Always enforce Control Mode 5 (BMS Rate)
        Lochinvar_40001_Control_Mode.sendCommand(5)
        
        // Safety: Ensure Physical CFH Relays are OFF
        if (CFH1.state == ON) CFH1.sendCommand(OFF)
        if (CFH2.state == ON) CFH2.sendCommand(OFF)
    } 
    else if (Boiler_BMS_ENBLE.state == OFF) {
        // === RELAY/LEGACY MODE ===
        Lochinvar_40001_Control_Mode.sendCommand(0)
        
        if (Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) {
            if ((Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue != 0) {
                Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(0)
            }
        }
    
        if (Lochinvar_40003_Rate_Command.state instanceof Number) {
            if ((Lochinvar_40003_Rate_Command.state as Number).intValue != 0) {
                Lochinvar_40003_Rate_Command.sendCommand(0)
            }
        }
    }
end

// -----------------------------------------------------------------------------------
// RULE 2: MAIN FIRING LOOP (Runs every 15 seconds)
// -----------------------------------------------------------------------------------
rule "Hybrid Boiler PID Loop"
when
    Time cron "0/15 * * * * ?"
then
    if (Boiler_Test_Repeat.state == ON) return;
    
    // =======================================================================
    // MAINTENANCE MODE INTERCEPT
    // =======================================================================
    if (System_Maintenance_Mode.state == ON) {
        
        if (Boiler_Manual_Enable.state == ON) {
            Lochinvar_40001_Control_Mode.sendCommand(5)

            if (Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) {
                if ((Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue != 1) {
                     Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(1)
                }
            }

            var Number manualRate = 0
            if (Boiler_Manual_Rate.state instanceof Number) {
                manualRate = (Boiler_Manual_Rate.state as Number).intValue
            }
            
            if (Lochinvar_40003_Rate_Command.state == NULL || (Lochinvar_40003_Rate_Command.state as Number).intValue != manualRate) {
                   Lochinvar_40003_Rate_Command.sendCommand(manualRate)
            }
            
        } else {
             if (Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) {
                if ((Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue != 0) {
                    Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(0)
                }
            }
            if (Lochinvar_40003_Rate_Command.state instanceof Number) {
                if ((Lochinvar_40003_Rate_Command.state as Number).intValue != 0) {
                    Lochinvar_40003_Rate_Command.sendCommand(0)
                }
            }
        }
        
        pid_integral = 0.0
        Boiler_PID_Output.postUpdate(0)
        Boiler_Final_Command.postUpdate(0)
        return;
    }
    
    // =======================================================================
    // STANDARD AUTOMATION LOGIC
    // =======================================================================
    
    if (Boiler_BMS_ENBLE.state != ON) {
        pid_integral = 0.0 
        return;
    }

    // 1. CHECK SHUTOFF BLOCK
    if (Boiler_Block_Active.state == ON) {
        pid_integral = 0.0 
        Boiler_PID_Output.postUpdate(0)
        Boiler_Final_Command.postUpdate(0)
        
        Lochinvar_40003_Rate_Command.sendCommand(0)
        
        if (Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) {
            if ((Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue != 0) {
                 logInfo("Boiler.BMS", "BLOCK ACTIVE: Forcing Enable=0 (Standby)")
                 Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(0)
            }
        }
    }

    // 2. GATHER DATA (Null-Safe)
    var double base_Kp = if(Boiler_Kp.state instanceof Number) (Boiler_Kp.state as Number).doubleValue else 2.5
    var double Ki = if(Boiler_Ki.state instanceof Number) (Boiler_Ki.state as Number).doubleValue else 0.1
    
    val Number supplyTemp  = if(System_Supply_Temp.state instanceof Number) (System_Supply_Temp.state as Number).doubleValue else 140.0
    val Number targetTemp = if(Boiler_Target_Temp.state instanceof Number) (Boiler_Target_Temp.state as Number).doubleValue else 0.0
    val Number outletTemp = if(Boiler_Outlet_Temp.state instanceof Number) (Boiler_Outlet_Temp.state as Number).doubleValue else 140.0

    // 3. PUMP ACTUATION 
    var boolean highTempCall = false
    var boolean lowTempCall = false

    if (LRZV.state == ON || GBrZV.state == ON || BMTZV.state == ON || GAZV.state == ON || MRZV.state == ON) highTempCall = true
    if (KITRH.state == ON || DENRH.state == ON || MBaRH.state == ON || MBeRH.state == ON) lowTempCall = true

    if (highTempCall) { 
        if (SysPump.state != ON) SysPump.sendCommand(ON) 
    } else { 
        if (SysPump.state != OFF) SysPump.sendCommand(OFF) 
    }

    if (lowTempCall) { 
        if (RHP.state != ON) RHP.sendCommand(ON) 
    } else { 
        if (RHP.state != OFF) RHP.sendCommand(OFF) 
    }
    
 // 3A. CALCULATE ZONE LOAD LIMIT (For Logging Only - Logic is now Unleashed)
    var int activeLoad = 0
    if (LRZV.state == ON)  activeLoad = activeLoad + 35 
    if (BMTZV.state == ON) activeLoad = activeLoad + 30 
    if (GAZV.state == ON)  activeLoad = activeLoad + 30 
    if (GBrZV.state == ON) activeLoad = activeLoad + 15 
    if (MRZV.state == ON)  activeLoad = activeLoad + 10 
    
    if (KITRH.state == ON) activeLoad = activeLoad + 20 
    if (DENRH.state == ON) activeLoad = activeLoad + 15 
    if (MBaRH.state == ON) activeLoad = activeLoad + 10 
    if (MBeRH.state == ON) activeLoad = activeLoad + 15 

    // Visual cap for graph consistency
    if (activeLoad > 100) activeLoad = 100
    if (activeLoad < 10 && (highTempCall || lowTempCall)) activeLoad = 20
    
    Boiler_Zone_Limit.postUpdate(activeLoad)
    val int zoneWeight = activeLoad

    // 4. FIRING PID (Only run if NOT Blocked)
    var Number finalRate = 0.0
    
    if (Boiler_Block_Active.state != ON) {
        
        if ((highTempCall || lowTempCall) && targetTemp > 0) {
            
            var Number error = targetTemp - supplyTemp
            
           // === SMART GAIN SCHEDULING ===
            // Buffer Tank Tune: More aggressive on large errors.
            var double dynamic_Kp = base_Kp
            
            if (error > 20) {
                dynamic_Kp = base_Kp * 0.6 // Increased from 0.2
            } else if (error > 10) {
                dynamic_Kp = base_Kp * 0.8 // Increased from 0.5
            }
            
            var Number P = dynamic_Kp * error
            pid_integral = pid_integral + (Ki * error)
            
            // Anti-Windup
            if (pid_integral > 25) {
                pid_integral = 25
                logInfo("Boiler.PID", "Anti-Windup Active: Target=" + targetTemp + " Actual=" + supplyTemp + " Dev=" + error + ". Pausing I-term.")
            }
            if (pid_integral < -10) pid_integral = -10
            
            var Number rawOutput = P + pid_integral
            Boiler_PID_Output.postUpdate(rawOutput)

            // === A. ZONE CLAMPING (BUFFER TANK MODE: UNLEASHED) ===
            // OLD LOGIC: var Number maxAllowed = zoneWeight * 1.5 
            // NEW LOGIC: If we have ANY demand, allow 100% fire. 
            // The Buffer Tank will absorb the energy.
            
            var Number maxAllowed = 100.0 
            
            // === B. SOFT GOVERNOR (Proportional Throttle) ===
            // Safety: Still throttle if OUTLET temp gets dangerous (180F+)
            // This protects the boiler heat exchanger, regardless of buffer tank.
            var double safetyLimit = 185.0
            var double governorStart = 175.0
            var double safetyFactor = 1.0
            
            if (outletTemp > governorStart) {
                var double headroom = safetyLimit - outletTemp
                
                if (headroom <= 0) {
                    safetyFactor = 0.0 // Hard Stop
                    logWarn("Boiler.Safety", "Governor: Outlet " + outletTemp + " exceeded limit! Killing rate.")
                } else {
                    // Linear reduction
                    safetyFactor = headroom / (safetyLimit - governorStart)
                    logInfo("Boiler.Safety", "Governor Active: Outlet=" + outletTemp + " throttling max output by " + ((1.0 - safetyFactor) * 100).intValue + "%")
                }
            }
            maxAllowed = maxAllowed * safetyFactor
            // ============================================

            if (rawOutput > maxAllowed) rawOutput = maxAllowed

            if (rawOutput < 10) {
                // Deadband: Math must demand at least 4% to start the boiler.
                if (rawOutput > 4.0) { finalRate = 10 } 
                else { finalRate = 0; pid_integral = 0 }
            } 
            else {
                finalRate = rawOutput
            }
            if (finalRate > 100) finalRate = 100
        } 
        else {
            finalRate = 0.0
            if (Boiler_Block_Active.state == ON) pid_integral = 0.0 
        }
    } 
    else {
        finalRate = 0.0
    }

    Boiler_Final_Command.postUpdate(finalRate)

    // 5. MODBUS COMMAND (FIXED ENABLE LOGIC)
    var int payload = finalRate.intValue
    var int desiredEnable = 0
    
    // --- THE FIX: Only Enable if Rate > 0 ---
    if (payload > 0) {
        desiredEnable = 1
    }
    
    // Send Enable Command First
    if (Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) {
        if ((Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue != desiredEnable) {
             Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(desiredEnable)
             // Short delay to let boiler process 'Enable' before seeing 'Rate'
             if (desiredEnable == 1) Thread::sleep(100) 
        }
    } else {
        // Fallback for NULL state
        Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(desiredEnable)
    }
    
    // Send Rate Command
    var int currentRate = -1
    if (Lochinvar_40003_Rate_Command.state instanceof Number) {
        currentRate = (Lochinvar_40003_Rate_Command.state as Number).intValue
    }
    
    if (currentRate != payload) {
        var int currentMode = 0
        if (Lochinvar_40001_Control_Mode.state instanceof Number) {
            currentMode = (Lochinvar_40001_Control_Mode.state as Number).intValue
        }
        
        // Enforce Control Mode 5 if firing
        if (currentMode != 5 && payload > 0) {
             Lochinvar_40001_Control_Mode.sendCommand(5)
             Thread::sleep(100) 
        }
        Lochinvar_40003_Rate_Command.sendCommand(payload)
    }
end

rule "Normalize Boiler State for Grafana"
when
    Item Boiler_Status_Code changed or
    Item Boiler_Blocking changed or
    Item Boiler_Lockout_Code changed
then
    var int graphState = 0
    var int status = if(Boiler_Status_Code.state instanceof Number) (Boiler_Status_Code.state as Number).intValue else 0
    var int block  = if(Boiler_Blocking.state instanceof Number) (Boiler_Blocking.state as Number).intValue else 0
    var int lock   = if(Boiler_Lockout_Code.state instanceof Number) (Boiler_Lockout_Code.state as Number).intValue else 32767

    if (lock != 32767) {
        graphState = -2
    }
    else if (block != 0 && block != 32767) {
        graphState = -1
        logInfo("Boiler.Monitor", "Boiler Soft Block Detected: Code " + block)
    }
    else if (status == 19) {
        graphState = 2
    }
    else if (status == 21 || status == 22 || status == 23) {
        graphState = 1
    }
    else {
        graphState = 0
    }

    if (Boiler_Graph_State.state != graphState) {
        Boiler_Graph_State.postUpdate(graphState)
    }
end