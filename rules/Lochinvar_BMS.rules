import org.openhab.core.model.script.ScriptServiceUtil

// ===================================================================================
// HYBRID LOCHINVAR LOGIC (Actuator & Firing Control)
// ===================================================================================

// -----------------------------------------------------------------------------------
// RULE 1: HEARTBEAT & WATCHDOG (Runs every minute)
// -----------------------------------------------------------------------------------
rule "Boiler Heartbeat and Mode Enforcement"
when
    Time cron "0 * * ? * *" 
then
    if (Boiler_Test_Repeat.state == ON) return;
    if (System_Maintenance_Mode.state == ON) return;

    // SAFETY CHECK: LOCKOUT
    val int lockoutCode = if(Boiler_Lockout_Code.state instanceof Number) (Boiler_Lockout_Code.state as Number).intValue else 32767
    
    if (lockoutCode != 32767) {
        logWarn("Boiler.Safety", "HARD LOCKOUT DETECTED (Code " + lockoutCode + "). BMS Control Paused.")
        return;
    }

    // NULL SAFETY CHECK
    if (Boiler_BMS_ENBLE.state == NULL || Boiler_BMS_ENBLE.state == UNDEF) {
        return;
    }

    if (Boiler_BMS_ENBLE.state == ON) {
        // === BMS MODE ===
        // Always enforce Control Mode 5 (BMS Rate)
        Lochinvar_40001_Control_Mode.sendCommand(5)
        
        // Safety: Ensure Physical CFH Relays are OFF
        if (CFH1.state == ON) CFH1.sendCommand(OFF)
        if (CFH2.state == ON) CFH2.sendCommand(OFF)
    } 
    else if (Boiler_BMS_ENBLE.state == OFF) {
        // === RELAY/LEGACY MODE ===
        Lochinvar_40001_Control_Mode.sendCommand(0)
        
        if (Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) {
            if ((Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue != 0) {
                Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(0)
            }
        }
    
        if (Lochinvar_40003_Rate_Command.state instanceof Number) {
            if ((Lochinvar_40003_Rate_Command.state as Number).intValue != 0) {
                Lochinvar_40003_Rate_Command.sendCommand(0)
            }
        }
    }
end

// -----------------------------------------------------------------------------------
// RULE 2: MAIN FIRING LOOP (Runs every 5 seconds)
// -----------------------------------------------------------------------------------
rule "Hybrid Boiler PID Loop"
when
    Time cron "0/5 * * * * ?"
then
    if (Boiler_Test_Repeat.state == ON) return;
    
    // =======================================================================
    // 1. FETCH MEMORY ITEMS (Robust Fetch)
    // =======================================================================
    var double mem_pid_integral = 0.0
    if (Boiler_Pid_Integral.state instanceof Number) {
        mem_pid_integral = (Boiler_Pid_Integral.state as Number).doubleValue
    }

    var double mem_limit_integral = 0.0
    if (Boiler_Limit_Integral.state instanceof Number) {
        mem_limit_integral = (Boiler_Limit_Integral.state as Number).doubleValue
    }

    var double mem_last_outlet = 0.0
    if (Boiler_Last_Outlet_Temp.state instanceof Number) {
        mem_last_outlet = (Boiler_Last_Outlet_Temp.state as Number).doubleValue
    }

    // =======================================================================
    // 2. MAINTENANCE MODE INTERCEPT
    // =======================================================================
    if (System_Maintenance_Mode.state == ON) {
        
        if (Boiler_Manual_Enable.state == ON) {
             Lochinvar_40001_Control_Mode.sendCommand(5)

            if (Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) {
                if ((Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue != 1) {
                     Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(1)
                }
            }

            var Number manualRate = 0
            if (Boiler_Manual_Rate.state instanceof Number) {
                manualRate = (Boiler_Manual_Rate.state as Number).intValue
            }
            
            if (Lochinvar_40003_Rate_Command.state == NULL || (Lochinvar_40003_Rate_Command.state as Number).intValue != manualRate) {
                   Lochinvar_40003_Rate_Command.sendCommand(manualRate)
            }
            
        } else {
             if (Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) {
                if ((Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue != 0) {
                     Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(0)
                }
            }
            if (Lochinvar_40003_Rate_Command.state instanceof Number) {
                if ((Lochinvar_40003_Rate_Command.state as Number).intValue != 0) {
                    Lochinvar_40003_Rate_Command.sendCommand(0)
                }
            }
        }
        
        // Reset Integrals on Maintenance
        if (mem_pid_integral != 0.0) Boiler_Pid_Integral.postUpdate(0)
        if (mem_limit_integral != 0.0) Boiler_Limit_Integral.postUpdate(0)
        
        Boiler_PID_Output.postUpdate(0)
        Boiler_Final_Command.postUpdate(0)
        return;
    }
    
    // =======================================================================
    // 3. STANDARD AUTOMATION LOGIC
    // =======================================================================
    
    if (Boiler_BMS_ENBLE.state != ON) {
        if (mem_pid_integral != 0.0) Boiler_Pid_Integral.postUpdate(0)
        if (mem_limit_integral != 0.0) Boiler_Limit_Integral.postUpdate(0)
        return;
    }

    // CHECK SHUTOFF BLOCK
    if (Boiler_Block_Active.state == ON) {
        if (mem_pid_integral != 0.0) Boiler_Pid_Integral.postUpdate(0)
        if (mem_limit_integral != 0.0) Boiler_Limit_Integral.postUpdate(0)
        
        Boiler_PID_Output.postUpdate(0)
        Boiler_Final_Command.postUpdate(0)
        Lochinvar_40003_Rate_Command.sendCommand(0)
        
        if (Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) {
            if ((Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue != 0) {
                 logInfo("Boiler.BMS", "BLOCK ACTIVE: Forcing Enable=0 (Standby)")
                 Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(0)
            }
        }
    }

    // GATHER TUNING & SENSORS
    var double base_Kp = if(Boiler_Kp.state instanceof Number) (Boiler_Kp.state as Number).doubleValue else 2.5
    var double Ki = if(Boiler_Ki.state instanceof Number) (Boiler_Ki.state as Number).doubleValue else 0.1
    
    val double supplyTemp  = if(System_Supply_Temp.state instanceof Number) (System_Supply_Temp.state as Number).doubleValue else 140.0
    val double targetTemp = if(Boiler_Target_Temp.state instanceof Number) (Boiler_Target_Temp.state as Number).doubleValue else 0.0
    val double outletTemp = if(Boiler_Outlet_Temp.state instanceof Number) (Boiler_Outlet_Temp.state as Number).doubleValue else 140.0

    // PUMP ACTUATION 
    var boolean highTempCall = false
    var boolean lowTempCall = false

    if (LRZV.state == ON || GBrZV.state == ON || BMTZV.state == ON || GAZV.state == ON || MRZV.state == ON) highTempCall = true
    if (KITRH.state == ON || DENRH.state == ON || MBaRH.state == ON || MBeRH.state == ON) lowTempCall = true

    if (highTempCall) { 
        if (SysPump.state != ON) SysPump.sendCommand(ON) 
    } else { 
        if (SysPump.state != OFF) SysPump.sendCommand(OFF) 
    }

    if (lowTempCall) { 
        if (RHP.state != ON) RHP.sendCommand(ON) 
    } else { 
        if (RHP.state != OFF) RHP.sendCommand(OFF) 
    }
    
    // CALCULATE ZONE LOAD LIMIT (Logging Only)
    var int activeLoad = 0
    if (LRZV.state == ON)  activeLoad = activeLoad + 35 
    if (BMTZV.state == ON) activeLoad = activeLoad + 30 
    if (GAZV.state == ON)  activeLoad = activeLoad + 30 
    if (GBrZV.state == ON) activeLoad = activeLoad + 15 
    if (MRZV.state == ON)  activeLoad = activeLoad + 10 
    if (KITRH.state == ON) activeLoad = activeLoad + 20 
    if (DENRH.state == ON) activeLoad = activeLoad + 15 
    if (MBaRH.state == ON) activeLoad = activeLoad + 10 
    if (MBeRH.state == ON) activeLoad = activeLoad + 15 

    if (activeLoad > 100) activeLoad = 100
    if (activeLoad < 10 && (highTempCall || lowTempCall)) activeLoad = 20
    Boiler_Zone_Limit.postUpdate(activeLoad)

    // 4. FIRING PID (OPTIMIZED)
    var double finalRate = 0.0
    var boolean update_pid_mem = false
    var boolean update_limit_mem = false
    
    if (Boiler_Block_Active.state != ON) {
    
       if ((highTempCall || lowTempCall) && targetTemp > 0) {
            
            // --- A. MAIN LOOP ---
            var double error = targetTemp - supplyTemp
            var double dynamic_Kp = base_Kp 
            var double P = dynamic_Kp * error
            
            // Anti-Windup
            var boolean systemMaxed = (Boiler_PID_Output.state as Number >= 100.0) && (error > 0)
            
            if (!systemMaxed) {
                mem_pid_integral = mem_pid_integral + ((Ki * 0.5) * error)
            } 
            
            // Integral Clamps
            if (mem_pid_integral > 50) mem_pid_integral = 50.0
            if (mem_pid_integral < -10) mem_pid_integral = -10.0
            
            // Trigger update of memory Item at end of rule
            update_pid_mem = true 
            
            var double mainOutput = P + mem_pid_integral
            
            if (mainOutput > 100) mainOutput = 100.0
            if (mainOutput < 0) mainOutput = 0.0
            
            Boiler_PID_Output.postUpdate(mainOutput)

            // =======================================================================
            // --- B. LIMIT LOOP (Gentle Braking) ---
            // =======================================================================
            var double limitOutput = 100.0
            
            // 1. Braking Threshold
            var double safetyThreshold = 165.0 
            
            // 2. Gains (GENTLE TUNE)
            var double limitKp = 4.0    // Was 6.0
            var double limitKd = 60.0   // Was 120.0
            var double limitKi = 1.0    
            
            if (outletTemp > safetyThreshold) {
                var double overshoot = outletTemp - safetyThreshold
                var double limitP = overshoot * limitKp
                
                var double rateOfChange = outletTemp - mem_last_outlet
                var double limitD = rateOfChange * limitKd
                
                // 3. Smart Integral
                if (rateOfChange > -0.1) {
                     mem_limit_integral = mem_limit_integral + (overshoot * limitKi)
                } else {
                     mem_limit_integral = mem_limit_integral * 0.95
                }
                
                if (mem_limit_integral > 100) mem_limit_integral = 100.0
                
                // Calculate Raw Brake Output
                limitOutput = 100.0 - limitP - mem_limit_integral - (limitD)
                
                // --- 4. MINIMUM MODULATION FLOOR (ANTI-STALL) ---
                if (limitOutput < 10.0 && outletTemp < 181.5) {
                    limitOutput = 10.0
                }

                update_limit_mem = true
                
                // 5. HARD CEILING (Software Kill Switch)
                if (outletTemp > 182.0) {
                     limitOutput = 0.0
                     logWarn("Boiler.Limit", "CRITICAL: Temp " + outletTemp + " > 182.0. Killing Output.")
                }
                
                // Final Clamps
                if (limitOutput < 0) limitOutput = 0.0
                if (limitOutput > 100) limitOutput = 100.0
                 
                logInfo("Boiler.Limit", "Limit Active: Temp=" + outletTemp + " Cmd=" + limitOutput.intValue + "% (P=" + limitP.intValue + " Floor=10%)")

            } else {
                // Cool down logic: Release brakes
                if (mem_limit_integral > 0.1) {
                    mem_limit_integral = mem_limit_integral - 2.0 
                    if (mem_limit_integral < 0) mem_limit_integral = 0.0
                    update_limit_mem = true
                }
            }
             
            if (mem_last_outlet != outletTemp) {
                Boiler_Last_Outlet_Temp.postUpdate(outletTemp)
            }
            
            // --- C. LOW SELECT ---
            var double rawOutput = mainOutput
            
            if (limitOutput < mainOutput) {
                 rawOutput = limitOutput
                if (mem_pid_integral > 0) {
                    // Unwind integral if hitting limit
                    mem_pid_integral = mem_pid_integral - (Ki * error) 
                    update_pid_mem = true
                }
            }

             // --- D. FINAL DEADBAND ---
            if (rawOutput < 15) {
                if (rawOutput > 8.0) { 
                    finalRate = 20.0 
                } else { 
                    finalRate = 0.0
                    mem_pid_integral = 0.0
                    mem_limit_integral = 0.0 
                    update_pid_mem = true
                    update_limit_mem = true
                }
            } 
            else {
                finalRate = rawOutput
            }
            if (finalRate > 100) finalRate = 100.0
        }
        else {
             finalRate = 0.0
             if (Boiler_Block_Active.state == ON) {
                mem_pid_integral = 0.0
                mem_limit_integral = 0.0
                update_pid_mem = true
                update_limit_mem = true
            }
        }
    } 
    else {
        finalRate = 0.0
    }

    // 5. UPDATE MEMORY ITEMS (Batch Update)
    if (update_pid_mem) Boiler_Pid_Integral.postUpdate(mem_pid_integral)
    if (update_limit_mem) Boiler_Limit_Integral.postUpdate(mem_limit_integral)

    // 6. MODBUS COMMAND
    Boiler_Final_Command.postUpdate(finalRate)
    var int payload = finalRate.intValue
    var int desiredEnable = 0
    if (payload > 0) desiredEnable = 1
    
    if (Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) {
        if ((Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue != desiredEnable) {
             Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(desiredEnable)
             if (desiredEnable == 1) Thread::sleep(100) 
        }
    } else {
        Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(desiredEnable)
    }
    
    var int currentRate = -1
    if (Lochinvar_40003_Rate_Command.state instanceof Number) {
        currentRate = (Lochinvar_40003_Rate_Command.state as Number).intValue
    }
    
    if (currentRate != payload) {
        var int currentMode = 0
        if (Lochinvar_40001_Control_Mode.state instanceof Number) {
            currentMode = (Lochinvar_40001_Control_Mode.state as Number).intValue
        }
        
        if (currentMode != 5 && payload > 0) {
             Lochinvar_40001_Control_Mode.sendCommand(5)
             Thread::sleep(100) 
        }
        Lochinvar_40003_Rate_Command.sendCommand(payload)
    }
end

rule "Normalize Boiler State for Grafana"
when
    Item Boiler_Status_Code changed or
    Item Boiler_Blocking changed or
    Item Boiler_Lockout_Code changed
then
    var int graphState = 0
    var int status = if(Boiler_Status_Code.state instanceof Number) (Boiler_Status_Code.state as Number).intValue else 0
    var int block  = if(Boiler_Blocking.state instanceof Number) (Boiler_Blocking.state as Number).intValue else 0
    var int lock   = if(Boiler_Lockout_Code.state instanceof Number) (Boiler_Lockout_Code.state as Number).intValue else 32767

    if (lock != 32767) {
        graphState = -2
    }
    else if (block != 0 && block != 32767) {
        graphState = -1
    }
    else if (status == 19) {
        graphState = 2
    }
    else if (status == 21 || status == 22 || status == 23) {
        graphState = 1
    }
    else {
        graphState = 0
    }

    if (Boiler_Graph_State.state != graphState) {
        Boiler_Graph_State.postUpdate(graphState)
    }
end