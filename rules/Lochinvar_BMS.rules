import org.openhab.core.model.script.ScriptServiceUtil

// ===================================================================================
// LOCHINVAR UNIFIED MASTER CONTROLLER - PROFESSIONAL EDITION
// Modes: 0=LEGACY, 1=BMS SETPOINT, 2=BMS FLOW (RATE)
// Updates: Alpha-Smoothing, Integral Freeze, Delta-T Policing
// ===================================================================================

// --- GLOBAL VARIABLES ---
var long last_demand_time = 0        // Tracks time of last VALID demand (PID > 5%)
var double last_firing_rate = 0.0    // Tracks Ramp Rate (Soft Start)
var boolean wwsd_active = false      // Tracks Warm Weather Shutdown State
var double lastSafeRate = 0.0        // Rate limiter for high limit jumps (Legacy var, kept for safety)

// NEW TIMERS
var long safety_trip_start_time = 0  // For High Limit Ride Through
var long wwsd_timer_start = 0        // For WWSD Hysteresis (1 Hour)
var long last_dhw_end_time = 0      // Tracks when DHW cycle finished

// -----------------------------------------------------------------------------------
// RULE 0: SYNC LEGACY SWITCH (Compatibility Bridge)
// -----------------------------------------------------------------------------------
rule "Sync Control Mode to Legacy Switch"
when
    Item Boiler_Control_Mode changed
then
    if (Boiler_Control_Mode.state instanceof Number) {
        var int mode = (Boiler_Control_Mode.state as Number).intValue
        if (mode > 0) {
            if (Boiler_BMS_ENBLE.state != ON) Boiler_BMS_ENBLE.postUpdate(ON)
        } else {
            if (Boiler_BMS_ENBLE.state != OFF) Boiler_BMS_ENBLE.postUpdate(OFF)
        }
    }
end

rule "Initialize Control Mode"
when
    System started
then
    if (Boiler_Control_Mode.state == NULL || Boiler_Control_Mode.state == UNDEF) {
        Boiler_Control_Mode.postUpdate(0) 
    }
end

// -----------------------------------------------------------------------------------
// RULE 1: HEARTBEAT & MODE ENFORCEMENT (Runs every minute)
// -----------------------------------------------------------------------------------
rule "Boiler Heartbeat and Mode Enforcement"
when
    Time cron "0 * * ? * *" 
then
    if (Boiler_Test_Repeat.state == ON) return;
    if (System_Maintenance_Mode.state == ON) return;
    if (Boiler_Control_Mode.state == NULL || Boiler_Control_Mode.state == UNDEF) return;

    val int mode = (Boiler_Control_Mode.state as Number).intValue
    val int lockoutCode = if(Boiler_Lockout_Code.state instanceof Number) (Boiler_Lockout_Code.state as Number).intValue else 32767
    
    // Check DHW Status (19 = DHW Mode)
    val int statusCode = if(Boiler_Status_Code.state instanceof Number) (Boiler_Status_Code.state as Number).intValue else 0
    
    if (lockoutCode != 32767) {
        logWarn("Boiler.Safety", "HARD LOCKOUT DETECTED (Code " + lockoutCode + "). BMS Control Paused.")
        return;
    }

    // Don't mess with config registers if DHW is running
    if (statusCode == 19) {
        return; 
    }

    if (mode == 1 || mode == 2) {
        Lochinvar_40001_Control_Mode.sendCommand(5)
        if (CFH1.state == ON) CFH1.sendCommand(OFF)
        if (CFH2.state == ON) CFH2.sendCommand(OFF)
    } 
    else {
        Lochinvar_40001_Control_Mode.sendCommand(0)
        var int currentEn = -1
        if (Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) currentEn = (Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue
        if (currentEn != 0) Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(0)
        
        if (Lochinvar_40003_Rate_Command.state instanceof Number) {
            if ((Lochinvar_40003_Rate_Command.state as Number).intValue != 0) Lochinvar_40003_Rate_Command.sendCommand(0)
        }
    }
end

// -----------------------------------------------------------------------------------
// RULE 2: BMS SETPOINT MANAGER (MODE 1)
// -----------------------------------------------------------------------------------
rule "Boiler Setpoint Manager (Mode 1)"
when
    Time cron "0/10 * * * * ?"
then
    if (Boiler_Control_Mode.state != 1) return;
    if (Boiler_Test_Repeat.state == ON) return;
    if (System_Maintenance_Mode.state == ON) return;

    // DHW CHECK: If Boiler is in DHW Mode (19), Exit Immediately.
    val int statusCode = if(Boiler_Status_Code.state instanceof Number) (Boiler_Status_Code.state as Number).intValue else 0
    if (statusCode == 19) {
        // Ensure Enable is held High so we don't kill the cycle
        if (Lochinvar_40002_Boiler_Enable_Cmd.state != 1) {
            Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(1)
        }
        return;
    }

    var double targetTemp = 0.0
    if (Boiler_Target_Temp.state instanceof Number) {
        targetTemp = (Boiler_Target_Temp.state as Number).doubleValue
    }
    
    var boolean isBlocked = (Boiler_Block_Active.state == ON)
    
    // SCALING FOR MODE 1 (Setpoint)
    val double boiler_min_setpoint = 70.0
    val double boiler_max_setpoint = 180.0
    var double finalPercent = 0.0
    var int desiredEnable = 0
    
    if (!isBlocked && targetTemp >= boiler_min_setpoint) {
        var double numerator = targetTemp - boiler_min_setpoint
        var double denominator = boiler_max_setpoint - boiler_min_setpoint
        if (denominator == 0) denominator = 1.0 
        finalPercent = (numerator / denominator) * 100.0
        
        if (finalPercent > 100.0) finalPercent = 100.0
        if (finalPercent < 0.0) finalPercent = 0.0
        
        desiredEnable = 1
        last_demand_time = now.millis
    }
    else {
        finalPercent = 0.0
        if (last_demand_time > 0 && (now.millis - last_demand_time) < 60000) {
            desiredEnable = 1
        } else {
            desiredEnable = 0
        }
    }

    var int currentEn = if(Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) (Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue else -1
    if (currentEn != desiredEnable) {
        Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(desiredEnable)
        Thread::sleep(100)
    }
    
    var int payload = finalPercent.intValue
    var int currentPayload = if(Lochinvar_40003_Rate_Command.state instanceof Number) (Lochinvar_40003_Rate_Command.state as Number).intValue else -1
    
    if (desiredEnable == 1 && currentPayload != payload) {
         Lochinvar_40003_Rate_Command.sendCommand(payload)
    }
    else if (desiredEnable == 0 && currentPayload != 0) {
         Lochinvar_40003_Rate_Command.sendCommand(0)
    }
    Boiler_Final_Command.postUpdate(payload)
end

// -----------------------------------------------------------------------------------
// RULE 3: BMS FLOW/RATE CONTROLLER (MODE 2) - Runs every 5s
// -----------------------------------------------------------------------------------
rule "Hybrid Boiler PID Loop (Mode 2)"
when
    Time cron "0/5 * * * * ?"
then
    if (Boiler_Control_Mode.state != 2) return;
    if (Boiler_Test_Repeat.state == ON) return;
    if (System_Maintenance_Mode.state == ON) {
        Boiler_PID_Output.postUpdate(0)
        return;
    }
    
    // 1. CHECK DHW STATUS (Status Code 19 = DHW)
    val int statusCode = if(Boiler_Status_Code.state instanceof Number) (Boiler_Status_Code.state as Number).intValue else 0
    
    // TRACK DHW TRANSITION
    if (statusCode == 19) {
        last_dhw_end_time = now.millis
        
        if (Lochinvar_40002_Boiler_Enable_Cmd.state != 1) {
            Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(1)
        }
        if (Lochinvar_40003_Rate_Command.state != 100) {
            Lochinvar_40003_Rate_Command.sendCommand(100)
        }
        logInfo("Boiler.DHW", "DHW Active (Code 19). BMS Paused.")
        return;
    }

    // 1. FETCH SENSORS & MEMORY
    var double mem_pid_integral = 0.0
    if (Boiler_Pid_Integral.state instanceof Number) mem_pid_integral = (Boiler_Pid_Integral.state as Number).doubleValue

    val double supplyTemp  = if(System_Supply_Temp.state instanceof Number) (System_Supply_Temp.state as Number).doubleValue else 140.0
    val double targetTemp  = if(Boiler_Target_Temp.state instanceof Number) (Boiler_Target_Temp.state as Number).doubleValue else 0.0
    val double outletTemp  = if(Boiler_Outlet_Temp.state instanceof Number) (Boiler_Outlet_Temp.state as Number).doubleValue else 140.0
    val double inletTemp   = if(Boiler_Inlet_Temp.state instanceof Number) (Boiler_Inlet_Temp.state as Number).doubleValue else 100.0
    val double pumpSpeed   = if(Boiler_Pump_Speed.state instanceof Number) (Boiler_Pump_Speed.state as Number).doubleValue else 0.0
    
    // --- POST-DHW CHILL OUT (IDLE AT 10%) ---
    // If DHW just finished (< 90 seconds ago), hold at 10% to prevent shutdown logic.
    if ((now.millis - last_dhw_end_time) < 90000) {
        logInfo("Boiler.DHW", "Post-DHW Chill Out Active. Holding Rate at 10%.")
        
        if (Lochinvar_40002_Boiler_Enable_Cmd.state != 1) {
            Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(1)
        }
        
        // Force Rate to 10% (Min Fire) to keep the flame and pump alive
        if (Lochinvar_40003_Rate_Command.state != 10) {
            Lochinvar_40003_Rate_Command.sendCommand(10)
        }
        return;
    }

    // --- UPDATED WWSD LOGIC ---
    var double effective_outdoor = 32.0 
    if (Outdoor_Temperature.state instanceof Number) effective_outdoor = (Outdoor_Temperature.state as Number).doubleValue
    else if (Weather_Current_Temperature.state instanceof Number) effective_outdoor = (Weather_Current_Temperature.state as Number).doubleValue

    var int hour = now.getHourOfDay
    var boolean sun_block_active = (hour >= 16 && hour < 18)

    if (!sun_block_active) {
        if (effective_outdoor >= 70.0) {
            if (wwsd_timer_start == 0) wwsd_timer_start = now.millis
            if ((now.millis - wwsd_timer_start) > 3600000) {
                if (!wwsd_active) {
                    wwsd_active = true
                    logInfo("Boiler.WWSD", "WWSD Activated (1 Hour Sustained Warmth)")
                }
            }
        } 
        else if (effective_outdoor <= 67.0) {
            wwsd_active = false
            wwsd_timer_start = 0
        }
    } else {
        if (effective_outdoor <= 67.0) wwsd_active = false
    }

    var double base_Kp = 3.0
    if (Boiler_Kp.state instanceof Number) base_Kp = (Boiler_Kp.state as Number).doubleValue
    var double Ki = 0.05 
    
    // 2. CALL DETECTION
    var boolean callActive = false
    if (LRZV.state == ON || GBrZV.state == ON || BMTZV.state == ON || GAZV.state == ON || MRZV.state == ON) callActive = true
    if (KITRH.state == ON || DENRH.state == ON || MBaRH.state == ON || MBeRH.state == ON) callActive = true
    if (wwsd_active) callActive = false

    // 3. PID & GOVERNOR PRE-CALCULATION
    var boolean update_pid_mem = false
    var double govOutletLimit = 100.0
    var double govFlowLimit = 100.0
    var double govPumpLimit = 100.0 
    var double pidRequest = 0.0
    var double error = 0.0
    
    // DEFINITIONS (Moved up for accessibility)
    val double min_fire = 10.0
    val double cruise_threshold = 12.0
    val double cutoff_threshold = 5.0

    if (Boiler_Block_Active.state != ON && callActive && targetTemp > 0) {
            
        // --- COMPONENT 1: PID ---
        error = targetTemp - supplyTemp
        var double P = base_Kp * error
        pidRequest = P + mem_pid_integral
        
        if (pidRequest > 100.0) pidRequest = 100.0
        if (pidRequest < 0.0) pidRequest = 0.0
        Boiler_PID_Output.postUpdate(pidRequest)

        // --- COMPONENT 2: CASCADE OVERRIDE (High Limit Governor) ---
        val double safetyTrip = 188.0     // Safety Trip Point
        val double modulationStart = 170.0 // Start modulating down here

        // 2. CALCULATE OVERRIDE
        if (outletTemp >= safetyTrip) {
            if (safety_trip_start_time == 0) safety_trip_start_time = now.millis
            if ((now.millis - safety_trip_start_time) > 5000) {
                govOutletLimit = 0.0
                logWarn("Boiler.Safety", "Approaching High Limit! Forced Shutdown at " + outletTemp)
            } else {
                govOutletLimit = 0.0 
            }
        } 
        else {
            safety_trip_start_time = 0
            if (outletTemp > modulationStart) {
                var double range = safetyTrip - modulationStart // 18.0 degrees
                var double offset = outletTemp - modulationStart
                var double ratio = offset / range 
                govOutletLimit = 100.0 - (ratio * 100.0)
                if (govOutletLimit < 0.0) govOutletLimit = 0.0
            }
        }

        // 3. DELTA T MONITOR (Passive Safety)
        // Active Delta T Policing (Pro BMS Feature)
        // If Delta T < 10F, we throttle the rate proportionally.
        var double boilerDeltaT = outletTemp - inletTemp
        
        if (boilerDeltaT < 10.0 && boilerDeltaT > 0.0) {
            // Throttle logic: (DT / 10) * 100
            // Example: DT = 5F -> 50% Limit
            govFlowLimit = (boilerDeltaT / 10.0) * 100.0
            if (govFlowLimit < 20.0) govFlowLimit = 20.0 
            logInfo("Boiler.Gov", "Delta-T Governor Active. Limiting to " + govFlowLimit.intValue + "%")
        } else {
            govFlowLimit = 100.0
        }

        // GOV C: Pump Speed Follower
        var double pump_match_target = 100.0
        if (pumpSpeed > 1.0) pump_match_target = pumpSpeed + 25.0
        else pump_match_target = 35.0
        if (pump_match_target > 100.0) pump_match_target = 100.0
        govPumpLimit = pump_match_target

        // --- UPDATE GOV ITEMS ---
        Boiler_Gov_Outlet.postUpdate(govOutletLimit)
        Boiler_Gov_Flow.postUpdate(govFlowLimit)
        Boiler_Gov_Pump.postUpdate(govPumpLimit)

        // ===============================================================================
        // PROFESSIONAL ARBITRATION & SMOOTHING (Replaces Simple Logic)
        // ===============================================================================
        
        // 1. RAW ARBITRATION (Who wins?)
        var double rawProposedRate = pidRequest
        var String limitingFactor = "PID"

        // Check Governors
        if (rawProposedRate > govOutletLimit) {
            rawProposedRate = govOutletLimit
            limitingFactor = "HighLimit_Gov"
        }
        // Only apply Flow/Pump limits if they are actually restrictive (avoid noise)
        if (rawProposedRate > govFlowLimit && govFlowLimit < 99.0) {
            rawProposedRate = govFlowLimit
            limitingFactor = "DeltaT_Gov"
        }
        
        // External Limits (Zone/Maintenance)
        var double externalLimit = 100.0
        if (Boiler_Zone_Limit.state instanceof Number) externalLimit = (Boiler_Zone_Limit.state as Number).doubleValue
        if (rawProposedRate > externalLimit) {
            rawProposedRate = externalLimit
            limitingFactor = "Zone_Limit"
        }

        // 2. INTEGRAL MANAGEMENT (Anti-Windup "Smart Freeze")
        // If we are being governed (limited) by safety, we MUST freeze the PID Integral.
        var boolean governorsActive = (rawProposedRate < pidRequest)
        var boolean startup_freeze = (outletTemp < inletTemp + 2.0)

        if (!startup_freeze) {
            if (!governorsActive) {
                // STANDARD OPERATION: Integrate normally
                mem_pid_integral = mem_pid_integral + ((Ki * 0.5) * error)
            } 
            else {
                // GOVERNOR ACTIVE: 
                // Commercial Standard: "Freeze and Decay". 
                // If Error is negative (Overshoot), allow I-term to drop. Otherwise freeze.
                if (error < 0) {
                     mem_pid_integral = mem_pid_integral + ((Ki * 0.5) * error)
                }
                logDebug("Boiler.PID", "Governor Active (" + limitingFactor + "). Freezing I-Term at " + String::format("%.1f", mem_pid_integral))
            }
        }
        
        // Safety Clamps for Integral
        if (mem_pid_integral > 50.0) mem_pid_integral = 50.0
        if (mem_pid_integral < -10.0) mem_pid_integral = -10.0
        update_pid_mem = true

        // 3. OUTPUT SMOOTHING (The "Rolls Royce" Filter)
        // Weighted Moving Average: alpha = 0.20 means 20% New, 80% Old.
        // This eliminates gas valve "jitter".
        val double alpha = 0.20 
        var double smoothedRate = 0.0

        // STARTUP JUMP: If we are OFF and want to start, bypass smoothing to prevent Deadband Trap
        // If last rate was 0, and we want > 10%, jump to 25% instantly to guarantee ignition
        if (last_firing_rate < 1.0 && rawProposedRate > min_fire) {
             smoothedRate = 25.0
             limitingFactor = "Ignition_Jump"
        } 
        else {
             smoothedRate = (alpha * rawProposedRate) + ((1.0 - alpha) * last_firing_rate)
             
             // Slew Rate Limiter (Mechanical Protection)
             val double maxRise = 2.0
             val double maxFall = 5.0 
             
             if (smoothedRate > last_firing_rate + maxRise) smoothedRate = last_firing_rate + maxRise
             if (smoothedRate < last_firing_rate - maxFall) smoothedRate = last_firing_rate - maxFall
        }

        // Absolute Clamps
        if (smoothedRate < 0.0) smoothedRate = 0.0
        if (smoothedRate > 100.0) smoothedRate = 100.0

        // 4. DEADBAND & CUTOFF
        var double finalRate = 0.0
        
        // TAILOUT Logic
        var boolean tailout = (smoothedRate < cruise_threshold && boilerDeltaT < 2.0 && pumpSpeed > 10.0)

        // Demand Timer Update
        if (smoothedRate > cutoff_threshold && !tailout) {
            last_demand_time = now.millis
        }

        if (tailout) {
            finalRate = 0.0
            logInfo("Boiler.Tailout", "TAILOUT: Low DeltaT (" + String::format("%.1f", boilerDeltaT) + ") at Min Fire. Saving Gas.")
        }
        else if (smoothedRate < cruise_threshold) {
             if (smoothedRate > cutoff_threshold) {
                 // Check debounce - if we just started, hold min fire
                 if ((now.millis - last_demand_time) < 10000) {
                     finalRate = min_fire 
                 } else {
                     finalRate = 0.0 
                 }
             } else {
                 finalRate = 0.0 // Shut down
             }
        } else {
            finalRate = smoothedRate
        }

        // 5. DIAGNOSTIC LOGGING (Factory Style)
        // Only log if active
        if (finalRate > 0 || last_firing_rate > 0) {
             logInfo("Boiler.Diagnostic", 
                "Tgt:" + String::format("%.1f", targetTemp) + 
                "|Sup:" + String::format("%.1f", supplyTemp) + 
                "|Out:" + String::format("%.1f", outletTemp) + 
                "|PID:" + String::format("%.1f", pidRequest) + 
                "|GovLim:" + String::format("%.1f", govOutletLimit) + 
                "|FINAL:" + String::format("%.1f", finalRate) +
                "|State:" + limitingFactor
            )
        }

        // 6. EXECUTION
        // Note: We use min_fire as threshold for Enable, but check smoothedRate to catch the Ignition Jump
        var int desiredEnable = if (finalRate >= min_fire || (smoothedRate > cutoff_threshold)) 1 else 0
        
        Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(desiredEnable)
        if (desiredEnable == 1) Thread::sleep(100)
        
        var int payload = finalRate.intValue
        var int currentRate = if(Lochinvar_40003_Rate_Command.state instanceof Number) (Lochinvar_40003_Rate_Command.state as Number).intValue else -1
        
        // Force update if Enable is HIGH, OR if we need to zero it out
        if (desiredEnable == 1 || (desiredEnable == 0 && currentRate > 0)) {
            if (currentRate != payload) {
                var int currentMode = if(Lochinvar_40001_Control_Mode.state instanceof Number) (Lochinvar_40001_Control_Mode.state as Number).intValue else 0
                if (currentMode != 5 && payload > 0) {
                     Lochinvar_40001_Control_Mode.sendCommand(5) // Force BMS Mode
                     Thread::sleep(100) 
                }
                Lochinvar_40003_Rate_Command.sendCommand(payload)
            }
        }
        
        // Update History
        last_firing_rate = finalRate
        Boiler_Final_Command.postUpdate(finalRate)

    } 
    else {
        // System OFF / Blocked / No Call
        if (Boiler_Block_Active.state == ON) {
            mem_pid_integral = 0.0
            update_pid_mem = true
        }
        Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(0)
        Lochinvar_40003_Rate_Command.sendCommand(0)
        last_firing_rate = 0.0
        Boiler_Final_Command.postUpdate(0)
    }

    if (update_pid_mem) Boiler_Pid_Integral.postUpdate(mem_pid_integral)
end

// -----------------------------------------------------------------------------------
// RULE 4: GRAFANA NORMALIZATION
// -----------------------------------------------------------------------------------
rule "Normalize Boiler State for Grafana"
when
    Item Boiler_Status_Code changed or
    Item Boiler_Blocking changed or
    Item Boiler_Lockout_Code changed
then
    var int graphState = 0
    var int status = if(Boiler_Status_Code.state instanceof Number) (Boiler_Status_Code.state as Number).intValue else 0
    var int block  = if(Boiler_Blocking.state instanceof Number) (Boiler_Blocking.state as Number).intValue else 0
    var int lock   = if(Boiler_Lockout_Code.state instanceof Number) (Boiler_Lockout_Code.state as Number).intValue else 32767

    if (lock != 32767) graphState = -2
    else if (block != 0 && block != 32767) graphState = -1
    else if (status == 19) graphState = 2
    else if (status == 21 || status == 22 || status == 23) graphState = 1
    else graphState = 0

    if (Boiler_Graph_State.state != graphState) {
        Boiler_Graph_State.postUpdate(graphState)
    }
end