import org.openhab.core.model.script.ScriptServiceUtil

// ===================================================================================
// LOCHINVAR UNIFIED MASTER CONTROLLER - PROFESSIONAL EDITION
// Modes: 0=LEGACY, 1=BMS SETPOINT, 2=BMS FLOW (RATE)
// Updates: 
// 1. Zero-Crossing Protection: 60s Hold when PID hits 0% to prevent short-cycling.
// 2. Condensing Optimizer: Linear modulation (Soft Guard) instead of hard cut.
// 3. Hardware Config: Minimum Fire Rate set to 10%.
// 4. Supervisor Reporting: Added Null-Safe Governor Status Reporting.
// 5. Minimum Run Time (MRT): Enforces 15-minute cycle to prevent purge losses.
// 6. Auto-Boost Logic: Smart Boost for Baseboards + Radiant Fatigue Protection.
// 7. Dynamic Tuning: Auto-Boost triggers now mapped to Items.
// 8. Room Feedback: Integrated Boiler_Max_Error from Thermostat.rules for Boost logic.
// 9. Standby Hygiene: Clean resets for all calculated items when system is OFF.
// 10. PID Tuning: Increased Outlet Kp to 2.0 for faster response.
// 11. Bug Fix: Moved Debug Logging after variable declaration.
// 12. Efficiency Logic Fix: "High Temp Required" = Baseboards Active AND Baseboard REQ > 140F.
// 13. Scope Fix: Moved 'desiredEnable' declaration to top level scope.
// 14. Efficiency Curve Tuning: Relaxed limits (130-145F) to prevent short cycling.
// 15. Single Zone Bypass: Disable Condensing Optimizer if only 1 High Temp zone is active.
// 16. PID Stability: Added Integral Freeze & Minimum Fire Hold when throttling.
// 17. Boost Logic Refinement: Excluded Garage from Radiant Fatigue check.
// 18. MRT Status: Updates Boiler_Block_Status and Boiler_MRT_Remaining.
// 19. PID UPGRADE: Added Derivative (D-Term) to dampen high-speed oscillation.
// 20. PID INIT FIX: Added robustness to force defaults if parameters are found to be 0.
// 21. MRT FIX: Added explicit reset of MRT Timer to 0 when System goes into Standby.
// 22. MRT DISPLAY FIX: Decoupled timer display from enforcement logic so it updates while running.
// 23. Efficiency Fix: Added Radiant Requirement (>140F) to 'isHighTempRequired' check to support mixing valve overhead.
// 24. DHW Handoff Fix: Added "DHW Blindfold" (Tank Control for 2m) and Minimum Fire Floor during Zero-Crossing.
// 25. DHW Continuity: Forces 10% Fire during DHW and Post-DHW to prevent Enable/Rate mismatch.
// 26. GLITCH PROTECTION: Aborts PID loop if Status Code is UNDEF/NULL to prevent false shutdowns.
// 27. HANDOFF STABILITY: Forces 'callActive' state during Post-DHW window to engage stabilization governor.
// 28. SIGNAL DEBOUNCE: Added 15s Hold-Up for Call Active to prevent "Ghost Call" shutdowns.
// ===================================================================================

// --- GLOBAL VARIABLES ---
var long last_demand_time = 0        // Tracks time of last VALID demand (PID > 5%)
var double last_firing_rate = 0.0    // Tracks Ramp Rate (Soft Start)
var boolean wwsd_active = false      // Tracks Warm Weather Shutdown State
var double lastSafeRate = 0.0        // Rate limiter for high limit jumps (Legacy var, kept for safety)
var double last_pid_error = 0.0      // Tracks Error for D-Term Calculation

// NEW TIMERS
var long safety_trip_start_time = 0  // For High Limit Ride Through
var long wwsd_timer_start = 0        // For WWSD Hysteresis (1 Hour)
var long last_dhw_end_time = 0      // Tracks when DHW cycle finished
var long cycle_start_time = 0        // Tracks when the current burn cycle started
var long last_valid_call_time = 0    // Debounce timer for Tstat dropouts

// -----------------------------------------------------------------------------------
// RULE 0: SYNC LEGACY SWITCH (Compatibility Bridge)
// -----------------------------------------------------------------------------------
rule "Sync Control Mode to Legacy Switch"
when
    Item Boiler_Control_Mode changed
then
    if (Boiler_Control_Mode.state instanceof Number) {
        var int mode = (Boiler_Control_Mode.state as Number).intValue
        if (mode > 0) {
            if (Boiler_BMS_ENBLE.state != ON) Boiler_BMS_ENBLE.postUpdate(ON)
        } else {
            if (Boiler_BMS_ENBLE.state != OFF) Boiler_BMS_ENBLE.postUpdate(OFF)
        }
    }
end

rule "Initialize Control Mode"
when
    System started
then
    if (Boiler_Control_Mode.state == NULL || Boiler_Control_Mode.state == UNDEF) {
        Boiler_Control_Mode.postUpdate(0) 
    }
    // Initialize the Dewpoint Switch (Default to ON for efficiency)
    if (Boiler_Dewpoint_Enable.state == NULL) {
        Boiler_Dewpoint_Enable.postUpdate(ON)
    }
    if (Boiler_Boost_Active.state == NULL) {
        Boiler_Boost_Active.postUpdate(OFF)
    }
    
    // Initialize Auto-Boost Tuning Defaults
    if (AutoBoost_Baseboard_Trigger.state == NULL) AutoBoost_Baseboard_Trigger.postUpdate(6.0)
    
    // UPDATED: Lowered Radiant Trigger default to 3.5 for faster response to lagging floors
    if (AutoBoost_Radiant_Trigger.state == NULL)   AutoBoost_Radiant_Trigger.postUpdate(3.5)
    
    // --- PID INITIALIZATION ---
    // Supply/Tank (Relaxed Mode - Pump Off or Low Demand)
    if (Boiler_Supply_Kp.state == NULL || Boiler_Supply_Kp.state == UNDEF) Boiler_Supply_Kp.postUpdate(1.0)
    if (Boiler_Supply_Ki.state == NULL || Boiler_Supply_Ki.state == UNDEF) Boiler_Supply_Ki.postUpdate(0.005)
    if (Boiler_Supply_Kd.state == NULL || Boiler_Supply_Kd.state == UNDEF) Boiler_Supply_Kd.postUpdate(0.0) // Default No D
    
    // Outlet (Aggressive Mode - Active Firing)
    // UPDATE: Increased Kp to 2.0 to improve tracking response and reduce I-Term load
    if (Boiler_Outlet_Kp.state == NULL || Boiler_Outlet_Kp.state == UNDEF) Boiler_Outlet_Kp.postUpdate(2.0)
    
    // ROBUST INIT: If Ki is missing OR Zero, force update to 0.1
    if (Boiler_Outlet_Ki.state == NULL || Boiler_Outlet_Ki.state == UNDEF || (Boiler_Outlet_Ki.state as Number).doubleValue == 0.0) {
        Boiler_Outlet_Ki.postUpdate(0.1)
    }
    
    // ROBUST INIT: If Kd is missing OR Zero, force update to 1.0 (Braking)
    if (Boiler_Outlet_Kd.state == NULL || Boiler_Outlet_Kd.state == UNDEF || (Boiler_Outlet_Kd.state as Number).doubleValue == 0.0) {
        Boiler_Outlet_Kd.postUpdate(1.0)
    }
end

// -----------------------------------------------------------------------------------
// RULE 1: HEARTBEAT & MODE ENFORCEMENT (Runs every minute)
// -----------------------------------------------------------------------------------
rule "Boiler Heartbeat and Mode Enforcement"
when
    Time cron "0 * * ? * *" 
then
    if (Boiler_Test_Repeat.state == ON) return;
    if (System_Maintenance_Mode.state == ON) return;
    if (Boiler_Control_Mode.state == NULL || Boiler_Control_Mode.state == UNDEF) return;

    val int mode = (Boiler_Control_Mode.state as Number).intValue
    val int lockoutCode = if(Boiler_Lockout_Code.state instanceof Number) (Boiler_Lockout_Code.state as Number).intValue else 32767
    
    // Check DHW Status (19 = DHW Mode)
    val int statusCode = if(Boiler_Status_Code.state instanceof Number) (Boiler_Status_Code.state as Number).intValue else 0
    
    if (lockoutCode != 32767) {
        logWarn("Boiler.Safety", "HARD LOCKOUT DETECTED (Code " + lockoutCode + "). BMS Control Paused.")
        return;
    }

    // Don't mess with config registers if DHW is running
    if (statusCode == 19) {
        return; 
    }

    if (mode == 1 || mode == 2) {
        // Enforce BMS Mode (5)
        Lochinvar_40001_Control_Mode.sendCommand(5)
    } 
    else {
        // Legacy Mode (0)
        Lochinvar_40001_Control_Mode.sendCommand(0)
        
        var int currentEn = -1
        if (Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) currentEn = (Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue
        if (currentEn != 0) Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(0)
        
        if (Lochinvar_40003_Rate_Command.state instanceof Number) {
            if ((Lochinvar_40003_Rate_Command.state as Number).intValue != 0) Lochinvar_40003_Rate_Command.sendCommand(0)
        }
    }
end

// -----------------------------------------------------------------------------------
// RULE 2: BMS SETPOINT MANAGER (MODE 1)
// -----------------------------------------------------------------------------------
rule "Boiler Setpoint Manager (Mode 1)"
when
    Time cron "0/10 * * * * ?"
then
    if (Boiler_Control_Mode.state != 1) return;
    if (Boiler_Test_Repeat.state == ON) return;
    if (System_Maintenance_Mode.state == ON) return;
    // DHW CHECK: If Boiler is in DHW Mode (19), Exit Immediately.
    val int statusCode = if(Boiler_Status_Code.state instanceof Number) (Boiler_Status_Code.state as Number).intValue else 0
    if (statusCode == 19) {
        if (Lochinvar_40002_Boiler_Enable_Cmd.state != 1) {
            Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(1)
        }
        return;
    }
    // DHW HANDOVER PROTECTION
    if ((now.millis - last_dhw_end_time) < 20000) {
        Boiler_PID_Output.postUpdate(0)
        Boiler_Final_Command.postUpdate(0)
        if (Lochinvar_40003_Rate_Command.state != 0) {
            Lochinvar_40003_Rate_Command.sendCommand(0)
        }
        return;
    }

    var double targetTemp = 0.0
    if (Boiler_Target_Temp.state instanceof Number) {
        targetTemp = (Boiler_Target_Temp.state as Number).doubleValue
    }
    
    var boolean isBlocked = (Boiler_Block_Active.state == ON)
    
    // SCALING FOR MODE 1 (Setpoint)
    val double boiler_min_setpoint = 70.0
    val double boiler_max_setpoint = 180.0
    var double finalPercent = 0.0
    var int desiredEnable = 0
    
    if (!isBlocked && targetTemp >= boiler_min_setpoint) {
        var double numerator = targetTemp - boiler_min_setpoint
        var double denominator = boiler_max_setpoint - boiler_min_setpoint
        if (denominator == 0) denominator = 1.0 
        finalPercent = (numerator / denominator) * 100.0
        
        if (finalPercent > 100.0) finalPercent = 100.0
        if (finalPercent < 0.0) finalPercent = 0.0
        
        desiredEnable = 1
        last_demand_time = now.millis
    }
    else {
        finalPercent = 0.0
        if (last_demand_time > 0 && (now.millis - last_demand_time) < 60000) {
            desiredEnable = 1
        } else {
            desiredEnable = 0
        }
    }

    var int currentEn = if(Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) (Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue else -1
    if (currentEn != desiredEnable) {
        Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(desiredEnable)
        Thread::sleep(100)
    }
    
    var int payload = finalPercent.intValue
    var int currentPayload = if(Lochinvar_40003_Rate_Command.state instanceof Number) (Lochinvar_40003_Rate_Command.state as Number).intValue else -1
    
    if (desiredEnable == 1 && currentPayload != payload) {
         Lochinvar_40003_Rate_Command.sendCommand(payload)
    }
    else if (desiredEnable == 0 && currentPayload != 0) {
         Lochinvar_40003_Rate_Command.sendCommand(0)
    }
    Boiler_Final_Command.postUpdate(payload)
end

// -----------------------------------------------------------------------------------
// RULE 2.5: AUTO-BOOST SUPERVISOR
// Monitors Room Error to engage Boost Mode if struggling.
// SMART: 
//   1. Baseboards: Fast Trigger (> 2.0F Error) for rapid recovery.
//   2. Radiant: Fatigue Trigger (> 1.5F Error) if efficiency fails.
// -----------------------------------------------------------------------------------
rule "Auto-Boost Supervisor"
when
    Item Boiler_Pid_Integral changed or
    Time cron "0 * * ? * *" // Run every minute as backup
then
    if (System_Maintenance_Mode.state == ON) return;
    // Fetch Max Room Error (from Thermostat.rules)
    var double maxRoomError = 0.0
    if (Boiler_Max_Error.state instanceof Number) maxRoomError = (Boiler_Max_Error.state as Number).doubleValue
    
    // Check Active Calls
    // EXCLUDE GARAGE: Garage is high temp but shouldn't prevent radiant fatigue logic.
    var boolean houseBaseboardActive = (LRZV.state == ON || GBrZV.state == ON || BMTZV.state == ON || MRZV.state == ON)
    var boolean garageActive = (GAZV.state == ON)
    
    var boolean boostOn = (Boiler_Boost_Active.state == ON)
    
    // LOGIC: Dual-Stage Hysteresis Control
    
    var boolean needBoost = false
    
    // STAGE 1: Fast Track (House Baseboards Need Heat NOW)
    // If a house baseboard room is > 2.0F below setpoint, we need Boost.
    if (houseBaseboardActive && maxRoomError > 2.0) {
        needBoost = true
        if (!boostOn) {
            logInfo("Boiler.Boost", "AUTO-BOOST ENGAGED: House Baseboard Error (" + String::format("%.1f", maxRoomError) + "F > 2.0F) detected.")
        }
    }
    
    // STAGE 2: Slow Track (Radiant Fatigue / Persistent Failure)
    // If NO house baseboards are running (Radiant only, or Radiant+Garage), and error is > 1.5F, boost.
    // This ensures Garage doesn't "mask" a radiant failure.
    if (!houseBaseboardActive && maxRoomError > 1.5) {
        needBoost = true
        if (!boostOn) {
            logInfo("Boiler.Boost", "AUTO-BOOST ENGAGED: Radiant Fatigue detected (Error=" + String::format("%.1f", maxRoomError) + "F > 1.5F). Efficiency Override.")
        }
    }
    
    // GARAGE BOOST: Specific check for Garage
    if (garageActive && maxRoomError > 4.0) { // Garage can tolerate larger swings
          needBoost = true
         if (!boostOn) logInfo("Boiler.Boost", "AUTO-BOOST ENGAGED: Garage Demand > 4.0F.")
    }
    
    // EXECUTION
    if (needBoost && !boostOn) {
        Boiler_Boost_Active.sendCommand(ON)
    }
    else if (!needBoost && boostOn && maxRoomError < 0.5) {
        // Disengage when satisfied (Hysteresis: Room within 0.5F of target)
        Boiler_Boost_Active.sendCommand(OFF)
        logInfo("Boiler.Boost", "AUTO-BOOST DISENGAGED: Room recovered (Error " + String::format("%.1f", maxRoomError) + "F < 0.5F).")
    }
end

// -----------------------------------------------------------------------------------
// RULE 3: HYBRID BOILER PID LOOP (MODE 2)
// Updates: "Condensing Optimizer", Caleffi Protection, Zero-Crossing, Governor Status,
//          Added Minimum Run Time (MRT) Logic, Added Boost Bypass,
//          Added Standby Hygiene (Resets when OFF)
// -----------------------------------------------------------------------------------
rule "Hybrid Boiler PID Loop (Mode 2)"
when
    Time cron "0/5 * * * * ?"
then
    if (Boiler_Control_Mode.state != 2) return;
    if (Boiler_Test_Repeat.state == ON) return;
    if (System_Maintenance_Mode.state == ON) {
        Boiler_PID_Output.postUpdate(0)
        return;
    }
    
    // 1. CHECK DHW STATUS (Status Code 19 = DHW)
    // FIX: Glitch Protection - If Sensor read fails (NULL/UNDEF), ABORT cycle to prevent defaulting to 0 and killing flame.
    if (Boiler_Status_Code.state == NULL || Boiler_Status_Code.state == UNDEF) {
        logWarn("Boiler.PID", "Status Code UNDEF/NULL - Skipping Cycle to prevent Glitch.")
        return;
    }
    
    val int statusCode = (Boiler_Status_Code.state as Number).intValue
    if (statusCode == 19) {
        last_dhw_end_time = now.millis
        if (Lochinvar_40002_Boiler_Enable_Cmd.state != 1) Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(1)
        
        // UPDATE: Send 10% instead of 0% to prevent Enable=1/Rate=0 conflict
        // Also pre-positions the boiler for smooth handoff when DHW ends.
        if (Lochinvar_40003_Rate_Command.state != 10) Lochinvar_40003_Rate_Command.sendCommand(10)
        
        logInfo("Boiler.DHW", "DHW Active (Code 19). BMS Paused (Holding 10%).")
        return;
    }

    // 2. FETCH SENSORS
    var double mem_pid_integral = 0.0
    if (Boiler_Pid_Integral.state instanceof Number) mem_pid_integral = (Boiler_Pid_Integral.state as Number).doubleValue

    val double supplyTemp  = if(System_Supply_Temp.state instanceof Number) (System_Supply_Temp.state as Number).doubleValue else 140.0
    
    // UPDATED: Changed to VAR to allow override during Handoff Logic
    var double targetTemp  = if(Boiler_Target_Temp.state instanceof Number) (Boiler_Target_Temp.state as Number).doubleValue else 0.0
    
    val double outletTemp  = if(Boiler_Outlet_Temp.state instanceof Number) (Boiler_Outlet_Temp.state as Number).doubleValue else 140.0
    val double inletTemp   = if(Boiler_Inlet_Temp.state instanceof Number) (Boiler_Inlet_Temp.state as Number).doubleValue else 100.0
    val double pumpSpeed   = if(Boiler_Pump_Speed.state instanceof Number) (Boiler_Pump_Speed.state as Number).doubleValue else 0.0

    // 3. SELECT SENSOR & PID STRATEGY
    var boolean useAggressiveMode = false
    var String tempSource = "Tank(Supply)"
    // We use Inlet for Dewpoint logic whenever pump is running, otherwise we trust Tank
    var double dewpointRefTemp = supplyTemp 
    
    // Configurable PID placeholders
    var double active_Kp = 1.0
    var double active_Ki = 0.01
    var double active_Kd = 0.0
    
    // Check for Post-DHW Stability Window (2 Minutes)
    var boolean postDhwWindow = (now.millis - last_dhw_end_time) < 120000

    if (pumpSpeed < 5.0 || postDhwWindow) {
        // --- MODE: TANK (RELAXED) ---
        useAggressiveMode = false
        if (postDhwWindow) tempSource = "Tank(DHW_Handoff)"
        else tempSource = "Tank(Supply)"
        
        dewpointRefTemp = supplyTemp
        
        // Use Relaxed PIDs
        if (Boiler_Supply_Kp.state instanceof Number) active_Kp = (Boiler_Supply_Kp.state as Number).doubleValue
        if (Boiler_Supply_Ki.state instanceof Number) active_Ki = (Boiler_Supply_Ki.state as Number).doubleValue
        if (Boiler_Supply_Kd.state instanceof Number) active_Kd = (Boiler_Supply_Kd.state as Number).doubleValue
    } 
    else {
        // --- MODE: INLET/BOILER (AGGRESSIVE) ---
        useAggressiveMode = true
        tempSource = "Inlet"
        dewpointRefTemp = inletTemp // Physics: Condensation happens at the inlet!
        // Use Aggressive PIDs
        if (Boiler_Outlet_Kp.state instanceof Number) active_Kp = (Boiler_Outlet_Kp.state as Number).doubleValue
        if (Boiler_Outlet_Ki.state instanceof Number) active_Ki = (Boiler_Outlet_Ki.state as Number).doubleValue
        if (Boiler_Outlet_Kd.state instanceof Number) active_Kd = (Boiler_Outlet_Kd.state as Number).doubleValue
    }

    // 4. CALL DETECTION & ERROR CALC
    var double pidRequest = 0.0
    var double error = 0.0
    var String controlVar = "Supply"

    var boolean callActive = false
    if (LRZV.state == ON || GBrZV.state == ON || BMTZV.state == ON || GAZV.state == ON || MRZV.state == ON) callActive = true
    if (KITRH.state == ON || DENRH.state == ON || MBaRH.state == ON || MBeRH.state == ON) callActive = true
    if (CFH1.state == ON || CFH2.state == ON || CFH3.state == ON) callActive = true 

    // FIX: Debounce "Ghost Calls" (Sensor Glitches)
    if (callActive) {
        last_valid_call_time = now.millis
    } else {
        // If we lost the call less than 15 seconds ago, assume it's a glitch and hold it true.
        if ((now.millis - last_valid_call_time) < 15000) {
            callActive = true
            // Only log sparingly to avoid spam, or check if we are actually running
            if (Lochinvar_40002_Boiler_Enable_Cmd.state == 1) {
                 logInfo("Boiler.Stability", "Call Signal Lost (Ghost): Holding Active for Debounce.")
            }
        }
    }
    
    // FIX: Force Active during Post-DHW Handoff to engage Stabilization Governor
    if (postDhwWindow) {
        callActive = true
        // Override targetTemp if it's zero (Standby) to ensure we enter the block.
        // The DHW Stabilization Logic will override the output to 10% anyway.
        if (targetTemp < 120.0) targetTemp = 120.0 
    }

    if (Boiler_Block_Active.state != ON && callActive && targetTemp > 0) {
        
        // --- CALCULATE ERROR ---
        if (useAggressiveMode) {
            error = targetTemp - outletTemp
            controlVar = "Outlet"
        } else {
            error = targetTemp - supplyTemp
            controlVar = "Supply"
        }

        // --- COMPONENT 1: PID CALC ---
        var double P = active_Kp * error
        
        // D-TERM ADDITION: Dampen the jitter
        var double D = active_Kd * (error - last_pid_error)
        last_pid_error = error // Update memory for next loop
        
        pidRequest = P + mem_pid_integral + D
        
        if (pidRequest > 100.0) pidRequest = 100.0
        if (pidRequest < 0.0) pidRequest = 0.0
        Boiler_PID_Output.postUpdate(pidRequest)

        // --- COMPONENT 2: GOVERNORS ---
        var double govOutletLimit = 100.0
        var double govFlowLimit = 100.0
        var double govDewpointLimit = 100.0 
        
        // Define Governor Limit Variable in Scope
        var double finalGovDewpointLimit = 100.0

        // 2A. HIGH LIMIT GOVERNOR (Safety)
        val double safetyTrip = 188.0
        val double modulationStart = 175.0
        if (outletTemp >= safetyTrip) govOutletLimit = 0.0
        else if (outletTemp > modulationStart) {
             var double ratio = (outletTemp - modulationStart) / (safetyTrip - modulationStart)
             govOutletLimit = 100.0 - (ratio * 100.0)
        }
        
        // 2B. DELTA T GOVERNOR (Heat Exchanger Protection)
        var double boilerDeltaT = outletTemp - inletTemp
        if (boilerDeltaT < 10.0 && boilerDeltaT > 0.0) { 
             govFlowLimit = (boilerDeltaT / 10.0) * 100.0
             if (govFlowLimit < 10.0) govFlowLimit = 10.0 
        }

        // 2C. CONDENSING EFFICIENCY OPTIMIZER (Linear Modulation)
        // REPLACES "Bang-Bang" Logic with Modulating Governor
        // Goal: Keep Return Temp < 135F for Efficiency, unless High Temp required.
        var boolean efficiencyEnabled = (Boiler_Dewpoint_Enable.state == ON)
        
        // Check Active Calls
        var boolean baseboardActive = (LRZV.state == ON || GBrZV.state == ON || BMTZV.state == ON || GAZV.state == ON || MRZV.state == ON)
        
        // FETCH ACTUAL BASEBOARD REQ (from outdoor_reset.rules)
        var double baseboardReq = 0.0
        if (ODR_Req_Baseboard.state instanceof Number) {
            baseboardReq = (ODR_Req_Baseboard.state as Number).doubleValue
        }
        
        // FETCH ACTUAL RADIANT REQ (from outdoor_reset.rules)
        var double radiantReq = 0.0
        if (ODR_Req_Radiant.state instanceof Number) {
            radiantReq = (ODR_Req_Radiant.state as Number).doubleValue
        }
        
        // REDEFINED: High Temp is only "Required" if:
        // 1. Baseboards are active AND requesting > 140F
        // 2. OR Radiant is active AND requesting > 140F (due to mixing valve overhead)
        var boolean isHighTempRequired = ((baseboardActive && baseboardReq >= 140.0) || (radiantReq >= 140.0))
        
        var boolean mixingValveStarving = (supplyTemp < 135.0 && isHighTempRequired)
        
        // BOOST MODE OVERRIDE: Manual Comfort Mode or Auto-Boost
        var boolean isBoostActive = (Boiler_Boost_Active.state == ON)
        
        // SINGLE ZONE BYPASS (Low Load Physics)
        var int highTempCount = 0
        if (HighTemp_Active_Count.state instanceof Number) highTempCount = (HighTemp_Active_Count.state as Number).intValue
        var boolean singleZoneBypass = (highTempCount == 1 && baseboardActive)

        if (efficiencyEnabled && !isHighTempRequired && !mixingValveStarving && !isBoostActive && !singleZoneBypass) {
             
             // --- NEW: DYNAMIC EFFICIENCY TARGET ---
             // Scales the throttle zone based on Outdoor Temp.
             // Formula: Base 130 + Correction (Warmer Outside = Lower Target)
             
             var double outdoorTmp = 32.0
             if (Outdoor_Temperature.state instanceof Number) outdoorTmp = (Outdoor_Temperature.state as Number).doubleValue
             
             // @50F Out: Starts at 121F (Aggressive)
             // @10F Out: Starts at 141F (Capacity priority)
             var double calc_start = 130.0 + ((32.0 - outdoorTmp) * 0.5)
             
             // Clamp limits for sanity
             if (calc_start < 120.0) calc_start = 120.0
             if (calc_start > 140.0) calc_start = 140.0
             
             val double eff_throttle_start = calc_start
             val double eff_throttle_end = calc_start + 10.0 // 10F Modulation Window
             
             if (dewpointRefTemp > eff_throttle_start) {
                 var double penaltyRatio = (dewpointRefTemp - eff_throttle_start) / (eff_throttle_end - eff_throttle_start)
                 if (penaltyRatio > 1.0) penaltyRatio = 1.0
                 
                 // Linearly reduce Max Fire from 100% down to 10% (Low Fire)
                 govDewpointLimit = 100.0 - (penaltyRatio * 90.0) 
                 
                 // Hard Cutoff (Kill Switch)
                 // Set to End of Throttle Window + 5F buffer to prevent bouncing
                 if (dewpointRefTemp > (eff_throttle_end + 5.0)) {
                     govDewpointLimit = 0.0
                     if (last_firing_rate > 0) {
                         logInfo("Boiler.Gov", "â›” EFFICIENCY LIMIT: Inlet too hot (" + dewpointRefTemp + "F > " + (eff_throttle_end + 5.0).intValue + "F). Killing Flame.")
                     }
                 } else if (pidRequest > govDewpointLimit) {
                     // Log only if we are actively restricting the PID
                     if (last_firing_rate > govDewpointLimit + 5) { // Debounce log
                         logInfo("Boiler.Gov", "ðŸ“‰ EFFICIENCY MODULATION: Restricting to " + govDewpointLimit.intValue + "% (Target: " + eff_throttle_start.intValue + "F)")
                     }
                 }
             }
        }
       
        finalGovDewpointLimit = govDewpointLimit // Store for MRT check

        // UPDATE GOV ITEMS
        Boiler_Gov_Outlet.postUpdate(govOutletLimit)
        Boiler_Gov_Flow.postUpdate(govFlowLimit)

        // --- COMPONENT 3: ARBITRATION ---
        var double rawProposedRate = pidRequest
        var String limitingFactor = controlVar + "_PID"

        if (rawProposedRate > govOutletLimit) {
            rawProposedRate = govOutletLimit
            limitingFactor = "HighLimit_Gov"
        }
        if (rawProposedRate > govFlowLimit && govFlowLimit < 99.0) {
            rawProposedRate = govFlowLimit
            limitingFactor = "DeltaT_Gov"
        }
        if (rawProposedRate > govDewpointLimit) {
            rawProposedRate = govDewpointLimit
            limitingFactor = "Condensing_Opt"
        }
        
        // Also check if we hit the HARD KILL (0.0)
        if (limitingFactor == "Condensing_Opt" && govDewpointLimit == 0.0) {
             limitingFactor = "Condensing_Opt_Kill"
        }

        // --- UPDATE SUPERVISOR ITEMS (NULL SAFE) ---
        // This allows us to see exactly which logic component is capping the boiler
        // CHECK 1: Ensure Status Item is Initialized
        if (Boiler_Gov_Status.state == NULL || Boiler_Gov_Status.state == UNDEF || Boiler_Gov_Status.state.toString != limitingFactor) {
            Boiler_Gov_Status.postUpdate(limitingFactor)
        }
        
        // CHECK 2: Ensure Rate Item is Initialized and Changed > 0.5%
        var double currentGovRate = 0.0
        if (Boiler_Gov_Rate.state instanceof Number) {
            currentGovRate = (Boiler_Gov_Rate.state as Number).doubleValue
        }
        
        if (Boiler_Gov_Rate.state == NULL || Boiler_Gov_Rate.state == UNDEF || Math.abs(currentGovRate - rawProposedRate) > 0.5) {
             Boiler_Gov_Rate.postUpdate(rawProposedRate)
        }

        // --- COMPONENT 4: INTEGRAL MANAGEMENT ---
        var boolean governorsActive = (rawProposedRate < pidRequest)
        var boolean startup_freeze = (outletTemp < inletTemp + 2.0)

        if (!startup_freeze) {
            // INTEGRAL FREEZE: Only accumulate if governors are NOT active.
            // This prevents "Windup" when the efficiency governor is throttling the boiler.
            if (!governorsActive) {
                mem_pid_integral = mem_pid_integral + ((active_Ki * 0.5) * error)
            } else {
                // Anti-Windup: Only accumulate if error helps us get OUT of saturation (i.e. error is negative)
                if (error < 0) mem_pid_integral = mem_pid_integral + ((active_Ki * 0.5) * error)
            }
        }
        
        if (mem_pid_integral > 50.0) mem_pid_integral = 50.0
        if (mem_pid_integral < -10.0) mem_pid_integral = -10.0
        Boiler_Pid_Integral.postUpdate(mem_pid_integral)

        // --- COMPONENT 5: SMOOTHING & OUTPUT ---
        var double finalRate = rawProposedRate
        
        // MINIMUM FIRE HOLD (Soft Landing)
        // If the Efficiency Governor is active AND the return temp is high (>135), 
        // Force the output to hover at 10% (Minimum Fire) instead of letting PID fight it.
        // This prevents the "57% -> 10% -> 57%" oscillation.
        if (limitingFactor == "Condensing_Opt" && dewpointRefTemp > 135.0) {
             finalRate = 10.0
        }
        
        // NEW: DHW STABILIZATION (Force 10% for 2 mins after DHW)
        // Prevents PID from reacting to the Temperature Delta during the "Heat Soak" mixing phase.
        if (postDhwWindow) {
             finalRate = 10.0
             limitingFactor = "DHW_Stabilization"
        }
        
        // HARDWARE LIMIT: Minimum Fire Rate = 10%
        if (finalRate < 10.0 && finalRate > 0.1) finalRate = 10.0 
        if (finalRate < 0.1) finalRate = 0.0

        // Ramp Rate Limits
        if (finalRate > last_firing_rate + 5.0) finalRate = last_firing_rate + 5.0
        if (finalRate < last_firing_rate - 10.0) finalRate = last_firing_rate - 10.0
        last_firing_rate = finalRate
        
        // LOGGING
        if (finalRate > 0) {
             logInfo("Boiler.PID", 
                "Mode:" + controlVar + 
                "|Err:" + String::format("%.1f", error) + 
                "|P:" + String::format("%.1f", P) + 
                "|I:" + String::format("%.1f", mem_pid_integral) + 
                "|D:" + String::format("%.1f", D) +
                "|Out:" + String::format("%.1f", finalRate) + 
                "|Lim:" + limitingFactor
            )
        }
        
        // --- EXECUTION COMMANDS (WITH ZERO-CROSSING PROTECTION & MRT) ---
        var int payload = finalRate.intValue
        var int desiredEnable = 0 
        
        // 1. STANDARD HYSTERESIS + ZERO-CROSSING HOLD
        if (Lochinvar_40002_Boiler_Enable_Cmd.state == 1) {
            if (payload >= 5) {
                desiredEnable = 1 // Stay ON down to 5%
                last_demand_time = now.millis // Reset the timer: We have valid demand
            } 
            else {
                // Demand dropped to < 5% (likely 0%).
                // HOLD ON for 60 seconds to see if it recovers.
                if (now.millis - last_demand_time < 60000) {
                    desiredEnable = 1
                    
                    // FIX: Force Minimum Fire (10%) to keep flame alive.
                    // Sending 0% Rate with Enable=1 causes Standby/Post-Purge.
                    if (payload < 10) {
                        payload = 10
                        finalRate = 10.0 // Sync variables for graph
                        logInfo("Boiler.PID", "Zero-Crossing: Holding Flame at 10%")
                    }
                } else {
                    desiredEnable = 0
                }
            }
        } else {
            if (payload >= 15) desiredEnable = 1 // Require 15% to Start
        }
        
        // DEBUG: MRT Diagnostics (Now valid because desiredEnable is defined)
         logInfo("Boiler.Debug", "MRT Check: CmdState=" + Lochinvar_40002_Boiler_Enable_Cmd.state + 
                ", Desired=" + desiredEnable + 
                ", StartTime=" + cycle_start_time + 
                ", Now=" + now.millis)

        // 2. MINIMUM RUN TIME ENFORCEMENT (BMS STANDARD)
        val long min_run = 900000 // 15 Minutes

        // Detect Cycle Start
        if (Lochinvar_40002_Boiler_Enable_Cmd.state != 1 && desiredEnable == 1) {
             cycle_start_time = now.millis
             logInfo("Boiler.Status", "Cycle Started. Min Run Time Active until " + now.plusMinutes(15))
        }

        // --- NEW: ALWAYS UPDATE MRT DISPLAY ---
        // This ensures the sitemap counts down even if the boiler is running normally (PID > 15%).
        if (Lochinvar_40002_Boiler_Enable_Cmd.state == 1 || desiredEnable == 1) {
            val long current_runtime = now.millis - cycle_start_time
            if (current_runtime < min_run) {
                var int minsRem = ((min_run - current_runtime) / 60000).intValue + 1
                // Update only if changed to reduce event bus spam
                if (Boiler_MRT_Remaining.state == NULL || (Boiler_MRT_Remaining.state as Number).intValue != minsRem) {
                     Boiler_MRT_Remaining.postUpdate(minsRem)
                }
            } else {
                // Timer Expired
                if (Boiler_MRT_Remaining.state instanceof Number && (Boiler_MRT_Remaining.state as Number).intValue != 0) {
                     Boiler_MRT_Remaining.postUpdate(0)
                }
            }
        }

        // Enforce Hold (If attempting to stop)
        if (Lochinvar_40002_Boiler_Enable_Cmd.state == 1 && desiredEnable == 0) {
             val long runtime = now.millis - cycle_start_time
             
             // UPDATED SAFETY CHECK:
             // 1. Outlet too hot (>188F)
             // 2. Efficiency Governor requests HARD KILL (0.0 limit)
             
             if (outletTemp > 188.0) {
                 logWarn("Boiler.Safety", "Minimum Run Time ABORTED: High Temp (" + outletTemp + "F)")
             }
             else if (runtime < min_run) {
                 desiredEnable = 1
                 if (payload < 10) payload = 10 // Force Idle at Min Fire
                 if (finalRate < 10.0) finalRate = 10.0 // Sync variables for graph
                 
                 // UPDATE STATUS
                 Boiler_Block_Status.postUpdate("MRT Active (Idle)")
                 // Update Remaining Time (Minutes)
                 var int minsRem = ((min_run - runtime) / 60000).intValue + 1
                 Boiler_MRT_Remaining.postUpdate(minsRem)
             }
        }
        
        Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(desiredEnable)
        if (desiredEnable == 1 || (Lochinvar_40003_Rate_Command.state as Number).intValue > 0) {
             Lochinvar_40003_Rate_Command.sendCommand(payload)
        }
        Boiler_Final_Command.postUpdate(finalRate)

    } else {
        // SYSTEM OFF
        if (Boiler_Block_Active.state == ON || !callActive) {
             mem_pid_integral = 0.0
             last_pid_error = 0.0 // Reset D-Term Memory
             Boiler_Pid_Integral.postUpdate(0)
             Boiler_PID_Output.postUpdate(0) 
             
             // New: Reset Governors
             Boiler_Gov_Outlet.postUpdate(100.0)
             Boiler_Gov_Flow.postUpdate(100.0)
             Boiler_Gov_Status.postUpdate("Standby")
             Boiler_Gov_Rate.postUpdate(0)
             
             // --- PROPOSED ADDITION ---
             Boiler_MRT_Remaining.postUpdate(0) // UNCOMMENTED
             // -------------------------

             Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(0)
             Lochinvar_40003_Rate_Command.sendCommand(0)
             Boiler_Final_Command.postUpdate(0)
             last_firing_rate = 0.0
        }
    }
end

// -----------------------------------------------------------------------------------
// RULE 4: GRAFANA NORMALIZATION
// -----------------------------------------------------------------------------------
rule "Normalize Boiler State for Grafana"
when
    Item Boiler_Status_Code changed or
    Item Boiler_Blocking changed or
    Item Boiler_Lockout_Code changed
then
    var int graphState = 0
    var int status = if(Boiler_Status_Code.state instanceof Number) (Boiler_Status_Code.state as Number).intValue else 0
    var int block  = if(Boiler_Blocking.state instanceof Number) (Boiler_Blocking.state as Number).intValue else 0
    var int lock   = if(Boiler_Lockout_Code.state instanceof Number) (Boiler_Lockout_Code.state as Number).intValue else 32767

    if (lock != 32767) graphState = -2
    else if (block != 0 && block != 32767) graphState = -1
    else if (status == 19) graphState = 2  // DHW
    else if (status == 18) graphState = 1  // SH
    else graphState = 0
    
    Boiler_Graph_State.postUpdate(graphState)
    
    // Update Mode Name
    var String mName = "Standby"
    if (graphState == 1) mName = "Heating"
    if (graphState == 2) mName = "DHW"
    if (graphState == -1) mName = "Blocking"
    if (graphState == -2) mName = "LOCKOUT"
    Boiler_Mode_Name.postUpdate(mName)
end