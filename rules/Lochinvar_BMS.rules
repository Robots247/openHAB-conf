import org.openhab.core.model.script.ScriptServiceUtil

// ===================================================================================
// HYBRID LOCHINVAR LOGIC (BMS Rate Control vs Relay Fallback)
// ===================================================================================

// PID Controller Variables
var Number pid_integral = 0.0
var Number last_run_time = 0

// -----------------------------------------------------------------------------------
// RULE 1: HEARTBEAT & WATCHDOG (Runs every minute)
// -----------------------------------------------------------------------------------
// This ensures the boiler Modbus connection stays alive and the mode is enforced.
// CRITICAL: We must re-send the command every minute to reset the boiler's watchdog timer.
rule "Boiler Heartbeat and Mode Enforcement"
when
    Time cron "0 * * ? * *" // Every Minute
then
    // CHECK MASTER SWITCH
    if (Boiler_BMS_ENBLE.state == ON) {
        // === BMS MODE ===
        
        // 1. Send ENABLE to Register 40002 (Value 1 = Enable Unit)
        // This ensures the boiler knows it has permission to fire.
        if ((Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue != 1) {
             logInfo("Boiler.Watchdog", "Heartbeat (BMS Mode): Enforcing Enable (40002=1)")
             Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(1)
        }

        // 2. Send CONFIG to Register 40001 (Value 5 = Enable + Rate)
        // Bit 0 (1) + Bit 2 (4) = 5.
        // This tells boiler: "Listen to Modbus for Enable AND Firing Rate."
        logInfo("Boiler.Watchdog", "Heartbeat (BMS Mode): Refreshing Register 40001 -> 5")
        Lochinvar_40001_Control_Mode.sendCommand(5)
        
        // Safety: Ensure Physical CFH Relays are OFF when in Rate Control Mode
        // We turn them off here to prevent "fighting" between physical inputs and Modbus.
        if (CFH1.state == ON) {
            logInfo("Boiler.Watchdog", "Safety: Turning OFF CFH1 Relay (BMS Mode Active)")
            CFH1.sendCommand(OFF)
        }
        if (CFH2.state == ON) {
            logInfo("Boiler.Watchdog", "Safety: Turning OFF CFH2 Relay (BMS Mode Active)")
            CFH2.sendCommand(OFF)
        }
    } 
    else {
        // === RELAY/LEGACY MODE ===
        // FORCE SEND '0' to Register 40001 every minute.
        // Value 0 = Use Physical Inputs (Legacy).
        logInfo("Boiler.Watchdog", "Heartbeat (Relay Mode): Refreshing Register 40001 -> 0")
        Lochinvar_40001_Control_Mode.sendCommand(0)
        
        // Reset Enable to 0 (Disable) via Modbus so physical takes over fully
        if ((Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue != 0) {
            Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(0)
        }

        // Safety: Ensure Rate Command is 0 when in Relay Mode so we don't confuse it
        if ((Lochinvar_40003_Rate_Command.state as Number).intValue != 0) {
            Lochinvar_40003_Rate_Command.sendCommand(0)
        }
    }
end

// -----------------------------------------------------------------------------------
// RULE 2: MAIN CONTROL LOOP (Runs every 15 seconds)
// -----------------------------------------------------------------------------------
rule "Hybrid Boiler PID Loop"
when
    Time cron "0/15 * * * * ?" // Every 15 seconds
then
    // 1. IF IN RELAY MODE, STOP HERE.
    if (Boiler_BMS_ENBLE.state != ON) {
        pid_integral = 0.0 // Reset PID
        return;
    }

    // 2. GET TUNING PARAMETERS (Live Update)
    var double Kp = if(Boiler_Kp.state instanceof Number) (Boiler_Kp.state as Number).doubleValue else 2.5
    var double Ki = if(Boiler_Ki.state instanceof Number) (Boiler_Ki.state as Number).doubleValue else 0.1
    var double Kd = if(Boiler_Kd.state instanceof Number) (Boiler_Kd.state as Number).doubleValue else 0.0

    // 3. GATHER SENSOR DATA
    // Default to safe values if sensors are NULL
    val Number outdoorTemp = if(Outdoor_Temperature.state instanceof Number) (Outdoor_Temperature.state as Number).doubleValue else 32.0
    val Number supplyTemp  = if(System_Supply_Temp.state instanceof Number) (System_Supply_Temp.state as Number).doubleValue else 140.0
    
    // 4. CALCULATE DEMAND (Zone Weighting)
    var int zoneWeight = 0
    var boolean highTempCall = false
    var boolean lowTempCall = false

    // --- High Temp Zones (Radiators/Baseboard/FanCoils) ---
    if (LRZV.state == ON)   { zoneWeight = zoneWeight + 20; highTempCall = true; }
    if (GBrZV.state == ON)  { zoneWeight = zoneWeight + 15; highTempCall = true; }
    if (BMTZV.state == ON)  { zoneWeight = zoneWeight + 15; highTempCall = true; }
    if (GAZV.state == ON)   { zoneWeight = zoneWeight + 25; highTempCall = true; }
    if (MRZV.state == ON)   { zoneWeight = zoneWeight + 5;  highTempCall = true; }
    // if (Heating_Boost_Active.state == ON) { zoneWeight = zoneWeight + 20; highTempCall = true; }

    // --- Radiant Zones (Low Temp) ---
    if (KITRH.state == ON)  { zoneWeight = zoneWeight + 10; lowTempCall = true; }
    if (DENRH.state == ON)  { zoneWeight = zoneWeight + 10; lowTempCall = true; }
    if (MBaRH.state == ON)  { zoneWeight = zoneWeight + 5;  lowTempCall = true; }
    if (MBeRH.state == ON)  { zoneWeight = zoneWeight + 5;  lowTempCall = true; }

    // Cap Weight at 100%
    if (zoneWeight > 100) zoneWeight = 100
    Boiler_Zone_Limit.postUpdate(zoneWeight)

    // 5. PUMP CONTROL (GPIO)
    // Manage external pumps based on demand type
    if (highTempCall) {
        if (SysPump.state != ON) SysPump.sendCommand(ON)
    } else {
        // Optional: Run-on timer could go here, for now turn off instantly
        if (SysPump.state != OFF) SysPump.sendCommand(OFF)
    }

    if (lowTempCall) {
        if (RHP.state != ON) RHP.sendCommand(ON)
    } else {
        if (RHP.state != OFF) RHP.sendCommand(OFF)
    }

    // 6. CALCULATE TARGET TEMP (Outdoor Reset Curves)
    var Number targetTemp = 0.0
    var String demandType = "None"

    if (highTempCall) {
        demandType = "High Temp"
        // High Curve: 0F Outdoor -> 180F Target | 60F Outdoor -> 130F Target
        targetTemp = 180.0 + (-0.83 * outdoorTemp) 
        if (targetTemp > 180) targetTemp = 180
        if (targetTemp < 130) targetTemp = 130
    } 
    else if (lowTempCall) {
        demandType = "Low Temp"
        // Low Curve: 0F Outdoor -> 120F Target | 60F Outdoor -> 90F Target
        targetTemp = 120.0 + (-0.5 * outdoorTemp)
        if (targetTemp > 120) targetTemp = 120
        if (targetTemp < 85) targetTemp = 85
    }

    Boiler_Demand_Type.postUpdate(demandType)
    Boiler_Target_Temp.postUpdate(targetTemp)

    // 7. PID CALCULATION
    var Number finalRate = 0.0
    
    // Only run PID if we actually have a zone calling
    if (zoneWeight > 0 && targetTemp > 0) {
        var Number error = targetTemp - supplyTemp
        
        var Number P = Kp * error
        pid_integral = pid_integral + (Ki * error)
        
        // Anti-Windup: Clamp Integral
        if (pid_integral > 40) pid_integral = 40
        if (pid_integral < -10) pid_integral = -10
        
        var Number rawOutput = P + pid_integral
        
        Boiler_PID_Output.postUpdate(rawOutput)

        // 8. OUTPUT CLAMPING & SAFETY (The Crucial Part)
        // =================================================
        
        // A. Load Limiting: Don't fire 100% if only one tiny zone is open
        var Number maxAllowed = zoneWeight * 1.5 // Allow some overhead
        if (maxAllowed > 100) maxAllowed = 100
        if (rawOutput > maxAllowed) rawOutput = maxAllowed

        // B. Minimum Fire Logic (Prevent Short Cycling)
        // Boiler shuts off below 10%. We must be >= 10 or 0.
        if (rawOutput < 10) {
            // Hysteresis: If we are really close (e.g. calculated 8%), 
            // stay at 10% to prevent short cycling unless we are WAY over temp.
            if (rawOutput > 1) {
                finalRate = 10 // Hold minimum fire
            } else {
                finalRate = 0  // Shut off if error is negative enough
                pid_integral = 0 // Reset integral to stop accumulation while off
            }
        } else {
            finalRate = rawOutput
        }
        
        // C. Absolute Max
        if (finalRate > 100) finalRate = 100

    } else {
        // No Zones calling
        finalRate = 0.0
        pid_integral = 0.0
    }

    Boiler_Final_Command.postUpdate(finalRate)

    // 9. SEND COMMAND TO MODBUS (With Pre-Flight Check)
    // In Config Mode 3 (Value 4), sending 0 shuts boiler off. Sending > 0 fires it.
    var int payload = finalRate.intValue
    
    // Only send if value changed to reduce bus traffic, OR if payload is > 0 (Active Heating)
    if (Lochinvar_40003_Rate_Command.state == NULL || 
        (Lochinvar_40003_Rate_Command.state as Number).intValue != payload) {
        
        // PRE-FLIGHT: Ensure Mode is correct before sending Rate
        // We force 5 (Enable + Rate) to ensure both bits are active
        if ((Lochinvar_40001_Control_Mode.state as Number).intValue != 5) {
             logInfo("Boiler.PID", "Pre-Flight Correction: Forcing Mode 5 before sending Rate " + payload)
             Lochinvar_40001_Control_Mode.sendCommand(5)
             // Slight pause to allow bus to process (optional, OpenHAB queues usually handle it)
             Thread::sleep(200) 
        }

        logInfo("Boiler.PID", "Updating Firing Rate: " + payload + "%")
        Lochinvar_40003_Rate_Command.sendCommand(payload)
    }
end