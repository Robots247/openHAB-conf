import org.openhab.core.model.script.ScriptServiceUtil

// ===================================================================================
// LOCHINVAR UNIFIED MASTER CONTROLLER - PROFESSIONAL EDITION
// Modes: 0=LEGACY, 1=BMS SETPOINT, 2=BMS FLOW (RATE)
// Updates: Added PID Initialization for Tank vs Outlet tuning
// ===================================================================================

// --- GLOBAL VARIABLES ---
var long last_demand_time = 0        // Tracks time of last VALID demand (PID > 5%)
var double last_firing_rate = 0.0    // Tracks Ramp Rate (Soft Start)
var boolean wwsd_active = false      // Tracks Warm Weather Shutdown State
var double lastSafeRate = 0.0        // Rate limiter for high limit jumps (Legacy var, kept for safety)

// NEW TIMERS
var long safety_trip_start_time = 0  // For High Limit Ride Through
var long wwsd_timer_start = 0        // For WWSD Hysteresis (1 Hour)
var long last_dhw_end_time = 0      // Tracks when DHW cycle finished
var long cycle_start_time = 0        // Tracks when the current burn cycle started

// -----------------------------------------------------------------------------------
// RULE 0: SYNC LEGACY SWITCH (Compatibility Bridge)
// -----------------------------------------------------------------------------------
rule "Sync Control Mode to Legacy Switch"
when
    Item Boiler_Control_Mode changed
then
    if (Boiler_Control_Mode.state instanceof Number) {
        var int mode = (Boiler_Control_Mode.state as Number).intValue
        if (mode > 0) {
            if (Boiler_BMS_ENBLE.state != ON) Boiler_BMS_ENBLE.postUpdate(ON)
        } else {
            if (Boiler_BMS_ENBLE.state != OFF) Boiler_BMS_ENBLE.postUpdate(OFF)
        }
    }
end

rule "Initialize Control Mode"
when
    System started
then
    if (Boiler_Control_Mode.state == NULL || Boiler_Control_Mode.state == UNDEF) {
        Boiler_Control_Mode.postUpdate(0) 
    }
    // Initialize the Dewpoint Switch (Default to ON for efficiency, but user can toggle)
    if (Boiler_Dewpoint_Enable.state == NULL) {
        Boiler_Dewpoint_Enable.postUpdate(ON)
    }
    
    // --- PID INITIALIZATION ---
    // Supply/Tank (Relaxed Mode - Pump Off or Low Demand)
    if (Boiler_Supply_Kp.state == NULL || Boiler_Supply_Kp.state == UNDEF) Boiler_Supply_Kp.postUpdate(1.0)
    if (Boiler_Supply_Ki.state == NULL || Boiler_Supply_Ki.state == UNDEF) Boiler_Supply_Ki.postUpdate(0.005)
    
    // Outlet (Aggressive Mode - Active Firing)
    if (Boiler_Outlet_Kp.state == NULL || Boiler_Outlet_Kp.state == UNDEF) Boiler_Outlet_Kp.postUpdate(2.0)
    if (Boiler_Outlet_Ki.state == NULL || Boiler_Outlet_Ki.state == UNDEF) Boiler_Outlet_Ki.postUpdate(0.05)
end

// -----------------------------------------------------------------------------------
// RULE 1: HEARTBEAT & MODE ENFORCEMENT (Runs every minute)
// -----------------------------------------------------------------------------------
rule "Boiler Heartbeat and Mode Enforcement"
when
    Time cron "0 * * ? * *" 
then
    if (Boiler_Test_Repeat.state == ON) return;
    if (System_Maintenance_Mode.state == ON) return;
    if (Boiler_Control_Mode.state == NULL || Boiler_Control_Mode.state == UNDEF) return;

    val int mode = (Boiler_Control_Mode.state as Number).intValue
    val int lockoutCode = if(Boiler_Lockout_Code.state instanceof Number) (Boiler_Lockout_Code.state as Number).intValue else 32767
    
    // Check DHW Status (19 = DHW Mode)
    val int statusCode = if(Boiler_Status_Code.state instanceof Number) (Boiler_Status_Code.state as Number).intValue else 0
    
    if (lockoutCode != 32767) {
        logWarn("Boiler.Safety", "HARD LOCKOUT DETECTED (Code " + lockoutCode + "). BMS Control Paused.")
        return;
    }

    // Don't mess with config registers if DHW is running
    if (statusCode == 19) {
        return; 
    }

    if (mode == 1 || mode == 2) {
        // Enforce BMS Mode (5)
        Lochinvar_40001_Control_Mode.sendCommand(5)
    } 
    else {
        // Legacy Mode (0)
        Lochinvar_40001_Control_Mode.sendCommand(0)
        
        var int currentEn = -1
        if (Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) currentEn = (Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue
        if (currentEn != 0) Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(0)
        
        if (Lochinvar_40003_Rate_Command.state instanceof Number) {
            if ((Lochinvar_40003_Rate_Command.state as Number).intValue != 0) Lochinvar_40003_Rate_Command.sendCommand(0)
        }
    }
end

// -----------------------------------------------------------------------------------
// RULE 2: BMS SETPOINT MANAGER (MODE 1)
// -----------------------------------------------------------------------------------
rule "Boiler Setpoint Manager (Mode 1)"
when
    Time cron "0/10 * * * * ?"
then
    if (Boiler_Control_Mode.state != 1) return;
    if (Boiler_Test_Repeat.state == ON) return;
    if (System_Maintenance_Mode.state == ON) return;

    // DHW CHECK: If Boiler is in DHW Mode (19), Exit Immediately.
    val int statusCode = if(Boiler_Status_Code.state instanceof Number) (Boiler_Status_Code.state as Number).intValue else 0
    if (statusCode == 19) {
        if (Lochinvar_40002_Boiler_Enable_Cmd.state != 1) {
            Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(1)
        }
        return;
    }
    // DHW HANDOVER PROTECTION
    if ((now.millis - last_dhw_end_time) < 20000) {
        Boiler_PID_Output.postUpdate(0)
        Boiler_Final_Command.postUpdate(0)
        if (Lochinvar_40003_Rate_Command.state != 0) {
            Lochinvar_40003_Rate_Command.sendCommand(0)
        }
        return;
    }

    var double targetTemp = 0.0
    if (Boiler_Target_Temp.state instanceof Number) {
        targetTemp = (Boiler_Target_Temp.state as Number).doubleValue
    }
    
    var boolean isBlocked = (Boiler_Block_Active.state == ON)
    
    // SCALING FOR MODE 1 (Setpoint)
    val double boiler_min_setpoint = 70.0
    val double boiler_max_setpoint = 180.0
    var double finalPercent = 0.0
    var int desiredEnable = 0
    
    if (!isBlocked && targetTemp >= boiler_min_setpoint) {
        var double numerator = targetTemp - boiler_min_setpoint
        var double denominator = boiler_max_setpoint - boiler_min_setpoint
        if (denominator == 0) denominator = 1.0 
        finalPercent = (numerator / denominator) * 100.0
        
        if (finalPercent > 100.0) finalPercent = 100.0
        if (finalPercent < 0.0) finalPercent = 0.0
        
        desiredEnable = 1
        last_demand_time = now.millis
    }
    else {
        finalPercent = 0.0
        if (last_demand_time > 0 && (now.millis - last_demand_time) < 60000) {
            desiredEnable = 1
        } else {
            desiredEnable = 0
        }
    }

    var int currentEn = if(Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) (Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue else -1
    if (currentEn != desiredEnable) {
        Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(desiredEnable)
        Thread::sleep(100)
    }
    
    var int payload = finalPercent.intValue
    var int currentPayload = if(Lochinvar_40003_Rate_Command.state instanceof Number) (Lochinvar_40003_Rate_Command.state as Number).intValue else -1
    
    if (desiredEnable == 1 && currentPayload != payload) {
         Lochinvar_40003_Rate_Command.sendCommand(payload)
    }
    else if (desiredEnable == 0 && currentPayload != 0) {
         Lochinvar_40003_Rate_Command.sendCommand(0)
    }
    Boiler_Final_Command.postUpdate(payload)
end

// -----------------------------------------------------------------------------------
// RULE 3: HYBRID BOILER PID LOOP (MODE 2)
// Updates: Integrated "Pump Speed" sensor selection with Mixing Valve Protection
// -----------------------------------------------------------------------------------
rule "Hybrid Boiler PID Loop (Mode 2)"
when
    Time cron "0/5 * * * * ?"
then
    if (Boiler_Control_Mode.state != 2) return;
    if (Boiler_Test_Repeat.state == ON) return;
    if (System_Maintenance_Mode.state == ON) {
        Boiler_PID_Output.postUpdate(0)
        return;
    }
    
    // 1. CHECK DHW STATUS (Status Code 19 = DHW)
    val int statusCode = if(Boiler_Status_Code.state instanceof Number) (Boiler_Status_Code.state as Number).intValue else 0
    if (statusCode == 19) {
        last_dhw_end_time = now.millis
        if (Lochinvar_40002_Boiler_Enable_Cmd.state != 1) Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(1)
        if (Lochinvar_40003_Rate_Command.state != 0) Lochinvar_40003_Rate_Command.sendCommand(0)
        logInfo("Boiler.DHW", "DHW Active (Code 19). BMS Paused.")
        return;
    }

    // 2. FETCH SENSORS
    var double mem_pid_integral = 0.0
    if (Boiler_Pid_Integral.state instanceof Number) mem_pid_integral = (Boiler_Pid_Integral.state as Number).doubleValue

    val double supplyTemp  = if(System_Supply_Temp.state instanceof Number) (System_Supply_Temp.state as Number).doubleValue else 140.0
    val double targetTemp  = if(Boiler_Target_Temp.state instanceof Number) (Boiler_Target_Temp.state as Number).doubleValue else 0.0
    val double outletTemp  = if(Boiler_Outlet_Temp.state instanceof Number) (Boiler_Outlet_Temp.state as Number).doubleValue else 140.0
    val double inletTemp   = if(Boiler_Inlet_Temp.state instanceof Number) (Boiler_Inlet_Temp.state as Number).doubleValue else 100.0
    val double pumpSpeed   = if(Boiler_Pump_Speed.state instanceof Number) (Boiler_Pump_Speed.state as Number).doubleValue else 0.0

    // 3. SELECT SENSOR & PID STRATEGY (AUTO-DETECT)
    // Logic: 
    // - If Pump < 5% (OFF): We trust the Tank/Supply. Use Relaxed PIDs.
    // - If Pump >= 5% (ON): We trust the Boiler Loop (Inlet/Outlet). Use Aggressive PIDs.

    var boolean useAggressiveMode = false
    var String tempSource = "Tank(Supply)"
    var double monitorTemp = supplyTemp // Default to Supply
    
    // Configurable PID placeholders
    var double active_Kp = 1.0
    var double active_Ki = 0.01

    if (pumpSpeed < 5.0) {
        // --- MODE: TANK (RELAXED) ---
        useAggressiveMode = false
        monitorTemp = supplyTemp
        tempSource = "Tank(Supply)"
        
        // Use Relaxed PIDs (Supply Config)
        if (Boiler_Supply_Kp.state instanceof Number) active_Kp = (Boiler_Supply_Kp.state as Number).doubleValue
        if (Boiler_Supply_Ki.state instanceof Number) active_Ki = (Boiler_Supply_Ki.state as Number).doubleValue
    } 
    else {
        // --- MODE: INLET/BOILER (AGGRESSIVE) ---
        useAggressiveMode = true
        monitorTemp = inletTemp
        tempSource = "Inlet"
        
        // Use Aggressive PIDs (Outlet Config)
        if (Boiler_Outlet_Kp.state instanceof Number) active_Kp = (Boiler_Outlet_Kp.state as Number).doubleValue
        if (Boiler_Outlet_Ki.state instanceof Number) active_Ki = (Boiler_Outlet_Ki.state as Number).doubleValue
    }

    // 4. CALL DETECTION & ERROR CALC
    var double pidRequest = 0.0
    var double error = 0.0
    var String controlVar = "Supply"

    var boolean callActive = false
    if (LRZV.state == ON || GBrZV.state == ON || BMTZV.state == ON || GAZV.state == ON || MRZV.state == ON) callActive = true
    if (KITRH.state == ON || DENRH.state == ON || MBaRH.state == ON || MBeRH.state == ON) callActive = true
    if (CFH1.state == ON || CFH2.state == ON || CFH3.state == ON) callActive = true 

    if (Boiler_Block_Active.state != ON && callActive && targetTemp > 0) {
        
        // --- CALCULATE ERROR ---
        if (useAggressiveMode) {
            // In Aggressive Mode, we target the OUTLET temp for fast response
            error = targetTemp - outletTemp
            controlVar = "Outlet"
        } else {
            // In Relaxed Mode, we target the SUPPLY temp (Tank)
            error = targetTemp - supplyTemp
            controlVar = "Supply"
        }

        // --- COMPONENT 1: PID CALC ---
        var double P = active_Kp * error
        pidRequest = P + mem_pid_integral
        
        if (pidRequest > 100.0) pidRequest = 100.0
        if (pidRequest < 0.0) pidRequest = 0.0
        Boiler_PID_Output.postUpdate(pidRequest)

        // --- COMPONENT 2: GOVERNORS (Safety & Dewpoint) ---
        var double govOutletLimit = 100.0
        var double govFlowLimit = 100.0
        var double govDewpointLimit = 100.0 

        // 2A. HIGH LIMIT GOVERNOR
        val double safetyTrip = 188.0
        val double modulationStart = 175.0
        if (outletTemp >= safetyTrip) govOutletLimit = 0.0
        else if (outletTemp > modulationStart) {
             var double ratio = (outletTemp - modulationStart) / (safetyTrip - modulationStart)
             govOutletLimit = 100.0 - (ratio * 100.0)
        }
        
        // 2B. DELTA T GOVERNOR
        var double boilerDeltaT = outletTemp - inletTemp
        if (boilerDeltaT < 10.0 && boilerDeltaT > 0.0) { 
             govFlowLimit = (boilerDeltaT / 10.0) * 100.0
             if (govFlowLimit < 20.0) govFlowLimit = 20.0 
        }

      // 2C. DEWPOINT GUARD (EFFICIENCY & SHORT CYCLE PROTECTION)
        var boolean dewpointEnabled = (Boiler_Dewpoint_Enable.state == ON)
        var boolean isHighTempRequired = (targetTemp >= 155.0)

        // CRITICAL BYPASS: MIXING VALVE PROTECTION
        // If the active sensor (Tank or Inlet) is below 130F, we are "Starving".
        // We MUST fire to protect the mixing valve, ignoring efficiency rules.
        var boolean mixingValveStarving = (monitorTemp < 130.0)

        if (dewpointEnabled && !isHighTempRequired && !mixingValveStarving) {
             // We are in the "Efficiency Zone" (Above 130F, but not High Temp)
             // Goal: Prevent short-cycling when water is already "warm enough" (e.g. 132F).
             
             val double condensing_limit = 132.0   // Upper Limit (Turn off)
             val double restart_hysteresis = 10.0   // Drop required to restart
             val double restart_trigger = condensing_limit - restart_hysteresis // 130.0F

             if (monitorTemp >= condensing_limit) {
                  // CASE 1: TOO HOT - KILL FLAME
                  govDewpointLimit = 0.0
                  if (last_firing_rate > 0) {
                      logInfo("Boiler.Gov", "⛔ DEWPOINT LIMIT: Killing Flame. " + tempSource + " (" + monitorTemp + ") > " + condensing_limit)
                  }
             }
             else if (monitorTemp > restart_trigger) {
                  // CASE 2: DEADBAND (e.g. 132F) - PREVENT RESTART
                  
                  if (last_firing_rate < 1.0) {
                      // Boiler is OFF. Keep it OFF until we drop below 130F.
                      govDewpointLimit = 0.0
                      
                      // LOGGING: Only shout if the PID is trying to fire
                      if (pidRequest > 10.0) {
                         logInfo("Boiler.Gov", "⛔ DEWPOINT BLOCK: Requesting " + pidRequest.intValue + "% but " + tempSource + " is " + monitorTemp + "F. (Waiting for <" + restart_trigger + "F)")
                      }
                  } else {
                      // Boiler is ON. Just restrict it to Low Fire (20%) to extend the run.
                      govDewpointLimit = 10.0 
                  }
             } 
        }

        // UPDATE GOV ITEMS
        Boiler_Gov_Outlet.postUpdate(govOutletLimit)
        Boiler_Gov_Flow.postUpdate(govFlowLimit)

        // --- COMPONENT 3: ARBITRATION ---
        var double rawProposedRate = pidRequest
        var String limitingFactor = controlVar + "_PID"

        if (rawProposedRate > govOutletLimit) {
            rawProposedRate = govOutletLimit
            limitingFactor = "HighLimit_Gov"
        }
        if (rawProposedRate > govFlowLimit && govFlowLimit < 99.0) {
            rawProposedRate = govFlowLimit
            limitingFactor = "DeltaT_Gov"
        }
        if (rawProposedRate > govDewpointLimit) {
            rawProposedRate = govDewpointLimit
            limitingFactor = "Dewpoint_Guard"
        }

        // --- COMPONENT 4: INTEGRAL MANAGEMENT ---
        var boolean governorsActive = (rawProposedRate < pidRequest)
        var boolean startup_freeze = (outletTemp < inletTemp + 2.0)

        if (!startup_freeze) {
            if (!governorsActive) {
                mem_pid_integral = mem_pid_integral + ((active_Ki * 0.5) * error)
            } else {
                if (error < 0) mem_pid_integral = mem_pid_integral + ((active_Ki * 0.5) * error)
            }
        }
        
        if (mem_pid_integral > 50.0) mem_pid_integral = 50.0
        if (mem_pid_integral < -10.0) mem_pid_integral = -10.0
        Boiler_Pid_Integral.postUpdate(mem_pid_integral)

        // --- COMPONENT 5: SMOOTHING & OUTPUT ---
        var double finalRate = rawProposedRate
        
        if (finalRate < 10.0 && finalRate > 0.1) finalRate = 10.0 
        if (finalRate < 0.1) finalRate = 0.0

        // Ramp Rate Limits
        if (finalRate > last_firing_rate + 5.0) finalRate = last_firing_rate + 5.0
        if (finalRate < last_firing_rate - 10.0) finalRate = last_firing_rate - 10.0
        last_firing_rate = finalRate
        
        // LOGGING
        if (finalRate > 0) {
             logInfo("Boiler.PID", 
                "Mode:" + controlVar + 
                "|Err:" + String::format("%.1f", error) + 
                "|P:" + String::format("%.1f", P) + 
                "|I:" + String::format("%.1f", mem_pid_integral) + 
                "|Out:" + String::format("%.1f", finalRate) + 
                "|Lim:" + limitingFactor
            )
        }
        
        // EXECUTION COMMANDS
        var int payload = finalRate.intValue
        var int desiredEnable = if (payload >= 10) 1 else 0
        
        // HYSTERESIS: Prevent rapid toggling if hovering around 10%
        if (Lochinvar_40002_Boiler_Enable_Cmd.state == 1) {
            if (payload >= 5) desiredEnable = 1 // Stay ON down to 5%
        } else {
            if (payload >= 15) desiredEnable = 1 // Require 15% to Start
        }
        
        Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(desiredEnable)
        if (desiredEnable == 1 || (Lochinvar_40003_Rate_Command.state as Number).intValue > 0) {
             Lochinvar_40003_Rate_Command.sendCommand(payload)
        }
        Boiler_Final_Command.postUpdate(finalRate)

    } else {
        // SYSTEM OFF
        
        // --- DEBUGGING: Why are we OFF? ---
        if (callActive || targetTemp > 0) {
             if (Boiler_Block_Active.state == ON) {
                 logInfo("Boiler.Debug", "OFF REASON: Block Active (Shutoff Rule Triggered).")
             } else if (!callActive) {
                 logInfo("Boiler.Debug", "OFF REASON: No Active Call detected (Check Zone Valves).")
             } else if (targetTemp <= 0) {
                 logInfo("Boiler.Debug", "OFF REASON: Target Temp is 0.0 (Check ODR Rule).")
             }
        }

        if (Boiler_Block_Active.state == ON || !callActive) {
             mem_pid_integral = 0.0
             Boiler_Pid_Integral.postUpdate(0)
             
             Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(0)
             Lochinvar_40003_Rate_Command.sendCommand(0)
             Boiler_Final_Command.postUpdate(0)
             last_firing_rate = 0.0
        }
    }
end

// -----------------------------------------------------------------------------------
// RULE 4: GRAFANA NORMALIZATION
// -----------------------------------------------------------------------------------
rule "Normalize Boiler State for Grafana"
when
    Item Boiler_Status_Code changed or
    Item Boiler_Blocking changed or
    Item Boiler_Lockout_Code changed
then
    var int graphState = 0
    var int status = if(Boiler_Status_Code.state instanceof Number) (Boiler_Status_Code.state as Number).intValue else 0
    var int block  = if(Boiler_Blocking.state instanceof Number) (Boiler_Blocking.state as Number).intValue else 0
    var int lock   = if(Boiler_Lockout_Code.state instanceof Number) (Boiler_Lockout_Code.state as Number).intValue else 32767

    if (lock != 32767) graphState = -2
    else if (block != 0 && block != 32767) graphState = -1
    else if (status == 19) graphState = 2
    else if (status == 21 || status == 22 || status == 23) graphState = 1
    else graphState = 0

    if (Boiler_Graph_State.state != graphState) {
        Boiler_Graph_State.postUpdate(graphState)
    }
end
