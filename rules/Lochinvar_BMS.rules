import org.openhab.core.model.script.ScriptServiceUtil

// ===================================================================================
// HYBRID LOCHINVAR LOGIC (Actuator & Firing Control)
// ===================================================================================

// PID Controller Variables (Firing Loop Only)
var Number pid_integral = 0.0

// -----------------------------------------------------------------------------------
// RULE 1: HEARTBEAT & WATCHDOG (Runs every minute)
// -----------------------------------------------------------------------------------
rule "Boiler Heartbeat and Mode Enforcement"
when
    Time cron "0 * * ? * *" 
then
    if (Boiler_Test_Repeat.state == ON) {
        logInfo("Boiler.Watchdog", "Yielding to Test Mode. Heartbeat skipped.")
        return;
    }

    if (Boiler_BMS_ENBLE.state == ON) {
        // === BMS MODE ===
        
        // CONFLICT RESOLUTION: 
        // Only enforce Enable=1 if we are NOT currently blocked by the Shutoff Rule.
        if (Boiler_Block_Active.state != ON) {
            if ((Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue != 1) {
                 logInfo("Boiler.Watchdog", "Heartbeat: Enforcing Enable (40002=1)")
                 Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(1)
            }
        }
        
        // Always enforce Control Mode 5 (BMS Rate)
        Lochinvar_40001_Control_Mode.sendCommand(5)
        
        // Safety: Ensure Physical CFH Relays are OFF
        if (CFH1.state == ON) CFH1.sendCommand(OFF)
        if (CFH2.state == ON) CFH2.sendCommand(OFF)
    } 
    else {
        // === RELAY/LEGACY MODE ===
        Lochinvar_40001_Control_Mode.sendCommand(0)
        if ((Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue != 0) {
            Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(0)
        }
        if ((Lochinvar_40003_Rate_Command.state as Number).intValue != 0) {
            Lochinvar_40003_Rate_Command.sendCommand(0)
        }
    }
end

// -----------------------------------------------------------------------------------
// RULE 2: MAIN FIRING LOOP (Runs every 15 seconds)
// -----------------------------------------------------------------------------------
rule "Hybrid Boiler PID Loop"
when
    Time cron "0/15 * * * * ?"
then
    if (Boiler_Test_Repeat.state == ON) return;
    if (Boiler_BMS_ENBLE.state != ON) {
        pid_integral = 0.0 
        return;
    }

    // 1. CHECK SHUTOFF BLOCK
    // -----------------------------------------------------------------------
    if (Boiler_Block_Active.state == ON) {
        // == HARD SHUTDOWN SEQUENCE ==
        pid_integral = 0.0 
        Boiler_PID_Output.postUpdate(0)
        Boiler_Final_Command.postUpdate(0)
        
        // A. Send 0% Rate
        if (Lochinvar_40003_Rate_Command.state == NULL || (Lochinvar_40003_Rate_Command.state as Number).intValue != 0) {
             Lochinvar_40003_Rate_Command.sendCommand(0)
        }
        
        // B. Send DISABLE Command (Standby)
        if (Lochinvar_40002_Boiler_Enable_Cmd.state == NULL || (Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue != 0) {
             logInfo("Boiler.BMS", "BLOCK ACTIVE: Forcing Enable=0 (Standby)")
             Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(0)
        }
        // Fall through to keep pumps running (Purge Cycle)
    }

    // 2. GATHER DATA
    var double base_Kp = if(Boiler_Kp.state instanceof Number) (Boiler_Kp.state as Number).doubleValue else 2.5
    var double Ki = if(Boiler_Ki.state instanceof Number) (Boiler_Ki.state as Number).doubleValue else 0.1
    val Number supplyTemp  = if(System_Supply_Temp.state instanceof Number) (System_Supply_Temp.state as Number).doubleValue else 140.0
    val Number targetTemp = if(Boiler_Target_Temp.state instanceof Number) (Boiler_Target_Temp.state as Number).doubleValue else 0.0
    val int zoneWeight = if(Boiler_Zone_Limit.state instanceof Number) (Boiler_Zone_Limit.state as Number).intValue else 0

    // 3. PUMP ACTUATION 
    var boolean highTempCall = false
    var boolean lowTempCall = false

    if (LRZV.state == ON || GBrZV.state == ON || BMTZV.state == ON || GAZV.state == ON || MRZV.state == ON) highTempCall = true
    if (KITRH.state == ON || DENRH.state == ON || MBaRH.state == ON || MBeRH.state == ON) lowTempCall = true

    if (highTempCall) { if (SysPump.state != ON) SysPump.sendCommand(ON) } 
    else { if (SysPump.state != OFF) SysPump.sendCommand(OFF) }

    if (lowTempCall) { if (RHP.state != ON) RHP.sendCommand(ON) } 
    else { if (RHP.state != OFF) RHP.sendCommand(OFF) }

    // 4. FIRING PID (Only run if NOT Blocked)
    var Number finalRate = 0.0
    
    // We only calculate PID if Block is OFF
    if (Boiler_Block_Active.state != ON) {
        
        // Ensure Enable=1 if we are coming out of a block
        if ((Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue != 1) {
            Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(1)
        }

        if ((highTempCall || lowTempCall) && targetTemp > 0) {
            
            var Number error = targetTemp - supplyTemp
            
            // === SMART GAIN SCHEDULING (NEW) ===
            // Prevents 100% blast during step changes (Soft Start)
            var double dynamic_Kp = base_Kp
            
            if (error > 20) {
                // MASSIVE step change (e.g. 110F -> 160F). 
                // Reduce aggression to 20% to Soft Start.
                dynamic_Kp = base_Kp * 0.2 
            } else if (error > 10) {
                // Moderate step. Reduce aggression to 50%.
                dynamic_Kp = base_Kp * 0.5
            }
            // Else: Use full Kp for precision finishing
            
            var Number P = dynamic_Kp * error
            pid_integral = pid_integral + (Ki * error)
            
            if (pid_integral > 40) pid_integral = 40
            if (pid_integral < -10) pid_integral = -10
            
            var Number rawOutput = P + pid_integral
            Boiler_PID_Output.postUpdate(rawOutput)

            // Clamps
            var Number maxAllowed = zoneWeight * 1.5 
            if (maxAllowed > 100) maxAllowed = 100
            if (rawOutput > maxAllowed) rawOutput = maxAllowed

            if (rawOutput < 10) {
                if (rawOutput > 1) { finalRate = 10 } 
                else { finalRate = 0; pid_integral = 0 }
            } else {
                finalRate = rawOutput
            }
            if (finalRate > 100) finalRate = 100
        } 
        else {
            // No Demand
            finalRate = 0.0
            if (Boiler_Block_Active.state == ON) pid_integral = 0.0 
        }
    } 
    else {
        // Blocked - Ensure rate is 0
        finalRate = 0.0
    }

    Boiler_Final_Command.postUpdate(finalRate)

    // 5. MODBUS COMMAND
    var int payload = finalRate.intValue
    if (Lochinvar_40003_Rate_Command.state == NULL || (Lochinvar_40003_Rate_Command.state as Number).intValue != payload) {
        if ((Lochinvar_40001_Control_Mode.state as Number).intValue != 5) {
             Lochinvar_40001_Control_Mode.sendCommand(5)
             Thread::sleep(200) 
        }
        Lochinvar_40003_Rate_Command.sendCommand(payload)
    }
end