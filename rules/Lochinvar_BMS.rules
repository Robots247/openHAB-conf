import org.openhab.core.model.script.ScriptServiceUtil

// ===================================================================================
// HYBRID LOCHINVAR LOGIC (Smart Headroom Governor)
// ===================================================================================

// --- GLOBAL VARIABLES ---
var long last_demand_time = 0  

// -----------------------------------------------------------------------------------
// RULE 1: HEARTBEAT & WATCHDOG
// -----------------------------------------------------------------------------------
rule "Boiler Heartbeat and Mode Enforcement"
when
    Time cron "0 * * ? * *" 
then
    if (Boiler_Test_Repeat.state == ON) return;
    if (System_Maintenance_Mode.state == ON) return;

    val int lockoutCode = if(Boiler_Lockout_Code.state instanceof Number) (Boiler_Lockout_Code.state as Number).intValue else 32767
    
    if (lockoutCode != 32767) {
        logWarn("Boiler.Safety", "HARD LOCKOUT DETECTED (Code " + lockoutCode + "). BMS Control Paused.")
        return;
    }

    if (Boiler_BMS_ENBLE.state == ON) {
        Lochinvar_40001_Control_Mode.sendCommand(5)
        if (CFH1.state == ON) CFH1.sendCommand(OFF)
        if (CFH2.state == ON) CFH2.sendCommand(OFF)
    } 
    else if (Boiler_BMS_ENBLE.state == OFF) {
        Lochinvar_40001_Control_Mode.sendCommand(0)
        var int currentEn = -1
        if (Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) currentEn = (Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue
        
        if (currentEn != 0) Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(0)
        
        if (Lochinvar_40003_Rate_Command.state instanceof Number) {
            if ((Lochinvar_40003_Rate_Command.state as Number).intValue != 0) Lochinvar_40003_Rate_Command.sendCommand(0)
        }
    }
end

// -----------------------------------------------------------------------------------
// RULE 2: MAIN FIRING LOOP
// -----------------------------------------------------------------------------------
rule "Hybrid Boiler PID Loop"
when
    Time cron "0/5 * * * * ?"
then
    if (Boiler_Test_Repeat.state == ON) return;
    
    // =======================================================================
    // 1. FETCH SENSORS
    // =======================================================================
    var double mem_pid_integral = 0.0
    if (Boiler_Pid_Integral.state instanceof Number) {
        mem_pid_integral = (Boiler_Pid_Integral.state as Number).doubleValue
    }

    val double supplyTemp  = if(System_Supply_Temp.state instanceof Number) (System_Supply_Temp.state as Number).doubleValue else 140.0
    val double targetTemp  = if(Boiler_Target_Temp.state instanceof Number) (Boiler_Target_Temp.state as Number).doubleValue else 0.0
    val double outletTemp  = if(Boiler_Outlet_Temp.state instanceof Number) (Boiler_Outlet_Temp.state as Number).doubleValue else 140.0
    val double pumpSpeed   = if(Boiler_Pump_Speed.state instanceof Number) (Boiler_Pump_Speed.state as Number).doubleValue else 0.0
    
    // =======================================================================
    // 2. MAINTENANCE MODE INTERCEPT
    // =======================================================================
    if (System_Maintenance_Mode.state == ON) {
        if (mem_pid_integral != 0.0) Boiler_Pid_Integral.postUpdate(0)
        Boiler_PID_Output.postUpdate(0)
        Boiler_Final_Command.postUpdate(0)
        return;
    }
    
    if (Boiler_BMS_ENBLE.state != ON) {
        if (mem_pid_integral != 0.0) Boiler_Pid_Integral.postUpdate(0)
        return;
    }

    var double base_Kp = 3.0
    if (Boiler_Kp.state instanceof Number) base_Kp = (Boiler_Kp.state as Number).doubleValue
    var double Ki = 0.05 
    
    // =======================================================================
    // 3. PUMP ACTUATION
    // =======================================================================
    var boolean highTempCall = false
    if (LRZV.state == ON) highTempCall = true
    if (GBrZV.state == ON) highTempCall = true
    if (BMTZV.state == ON) highTempCall = true
    if (GAZV.state == ON) highTempCall = true
    if (MRZV.state == ON) highTempCall = true

    var boolean lowTempCall = false
    if (KITRH.state == ON) lowTempCall = true
    if (DENRH.state == ON) lowTempCall = true
    if (MBaRH.state == ON) lowTempCall = true
    if (MBeRH.state == ON) lowTempCall = true

    if (highTempCall) { if (SysPump.state != ON) SysPump.sendCommand(ON) } else { if (SysPump.state != OFF) SysPump.sendCommand(OFF) }
    if (lowTempCall) { if (RHP.state != ON) RHP.sendCommand(ON) } else { if (RHP.state != OFF) RHP.sendCommand(OFF) }
    
    // =======================================================================
    // 4. FIRING ARBITRATION LOGIC
    // =======================================================================
    var double finalRate = 0.0
    var boolean update_pid_mem = false
    
    var double govOutletLimit = 100.0
    var double govFlowLimit = 100.0
    var double govPumpLimit = 100.0 
    var double pidRequest = 0.0
    var double safeRate = 0.0
    var double severity = 0.0
    var double flowSeverity = 0.0
    
    if (Boiler_Block_Active.state != ON && (highTempCall || lowTempCall) && targetTemp > 0) {
            
        // ----------------------------------------
        // COMPONENT 1: MAIN PID
        // ----------------------------------------
        var double error = targetTemp - supplyTemp
        var double P = base_Kp * error
        
        pidRequest = P + mem_pid_integral
        
        if (pidRequest > 100.0) pidRequest = 100.0
        if (pidRequest < 0.0) pidRequest = 0.0
        
        Boiler_PID_Output.postUpdate(pidRequest)

        // ----------------------------------------
        // COMPONENT 2: THE GOVERNORS
        // ----------------------------------------
        
        // GOVERNOR A: Outlet Ceiling (Dynamic Headroom)
        val double hardLimit = 185.0
        var double calculatedStart = targetTemp + 4.0
        if (calculatedStart > 180.0) calculatedStart = 180.0

        val double outletMax = hardLimit
        val double outletStart = calculatedStart

        if (outletTemp > outletStart) {
            var double num = outletMax - outletTemp
            var double den = outletMax - outletStart
            if (den == 0) den = 1.0 
            
            severity = num / den
            govOutletLimit = severity * 100.0
        }
        
        // GOVERNOR B: Delta T Guard (Only when water is moving)
        if (pumpSpeed > 10.0) {
            val double dtMax = 30.0
            val double dtStart = 20.0
            var double sysDelta = outletTemp - supplyTemp
            
            if (sysDelta > dtStart) {
                 flowSeverity = (dtMax - sysDelta) / (dtMax - dtStart)
                 govFlowLimit = flowSeverity * 100.0
                 if (govFlowLimit < 0.0) govFlowLimit = 0.0
            }
        }

        // [OPTIMIZED] GOVERNOR C: Pump Speed Follower (Smart Headroom)
        // Professional Tuning: If we have Thermal Headroom (<165F), we ignore pump speed limits.
        // We only enforce Flow-Matching when we are approaching the safety limit.
        
        if (outletTemp < 165.0) {
            // SAFE ZONE: We have plenty of room before boiling. Allow 100% fire even if pump is slow.
            govPumpLimit = 100.0
        } 
        else {
            // DANGER ZONE: Approaching limit. Lock Fire to Flow to prevent flash-boil.
            if (pumpSpeed > 1.0) {
                govPumpLimit = pumpSpeed + 15.0
            } else {
                govPumpLimit = 25.0 // Startup Allowance
            }
        }
        
        if (govPumpLimit > 100.0) govPumpLimit = 100.0

        // ----------------------------------------
        // FINAL ARBITRATION
        // ----------------------------------------
        safeRate = pidRequest
        
        if (safeRate > govOutletLimit) safeRate = govOutletLimit
        if (safeRate > govFlowLimit) safeRate = govFlowLimit
        if (safeRate > govPumpLimit) safeRate = govPumpLimit
        
        if (safeRate < 0.0) safeRate = 0.0
        
        // ----------------------------------------
        // INTEGRAL MANAGEMENT
        // ----------------------------------------
        var boolean governorsActive = (safeRate < pidRequest)
        
        if (!governorsActive) {
            mem_pid_integral = mem_pid_integral + ((Ki * 0.5) * error)
        } 
        else {
            if (error < 0 && mem_pid_integral > 0) {
                mem_pid_integral = mem_pid_integral + ((Ki * 0.5) * error) 
            }
        }
        
        if (mem_pid_integral > 50.0) mem_pid_integral = 50.0
        if (mem_pid_integral < -10.0) mem_pid_integral = -10.0
        update_pid_mem = true

        // ----------------------------------------
        // FINAL DEADBAND & OUTPUT
        // ----------------------------------------
        if (safeRate < 15.0) {
            if (safeRate > 8.0) finalRate = 20.0 
            else { 
                finalRate = 0.0
                update_pid_mem = true
            }
        }
        else {
            finalRate = safeRate
        }
        
        if (finalRate > 100.0) finalRate = 100.0
        
    } 
    else {
        finalRate = 0.0
        if (Boiler_Block_Active.state == ON) {
            mem_pid_integral = 0.0
            update_pid_mem = true
        }
    }

    // 5. UPDATE MEMORY
    if (update_pid_mem) Boiler_Pid_Integral.postUpdate(mem_pid_integral)

    // 6. MODBUS COMMAND
    Boiler_Final_Command.postUpdate(finalRate)
    var int payload = (finalRate).intValue

    // -----------------------------------------------------------------------
    // ENABLE LOGIC
    // -----------------------------------------------------------------------
    if (payload > 0) {
        last_demand_time = now.millis
    }

    var boolean holdActive = (now.millis - last_demand_time) < 60000 
    
    var int desiredEnable = 0
    if (payload > 0 || holdActive) {
        desiredEnable = 1
    }

    if (Lochinvar_40002_Boiler_Enable_Cmd.state instanceof Number) {
        var int currentEn = (Lochinvar_40002_Boiler_Enable_Cmd.state as Number).intValue
        if (currentEn != desiredEnable) {
             Lochinvar_40002_Boiler_Enable_Cmd.sendCommand(desiredEnable)
             if (desiredEnable == 1) Thread::sleep(100) 
        }
    }
    
    var int currentRate = -1
    if (Lochinvar_40003_Rate_Command.state instanceof Number) {
        currentRate = (Lochinvar_40003_Rate_Command.state as Number).intValue
    }
    
    if (currentRate != payload) {
        var int currentMode = 0
        if (Lochinvar_40001_Control_Mode.state instanceof Number) {
            currentMode = (Lochinvar_40001_Control_Mode.state as Number).intValue
        }
        
        if (currentMode != 5 && payload > 0) {
             Lochinvar_40001_Control_Mode.sendCommand(5)
             Thread::sleep(100) 
        }
        Lochinvar_40003_Rate_Command.sendCommand(payload)
    }
end

// -----------------------------------------------------------------------------------
// RULE 3: GRAFANA NORMALIZATION
// -----------------------------------------------------------------------------------
rule "Normalize Boiler State for Grafana"
when
    Item Boiler_Status_Code changed or
    Item Boiler_Blocking changed or
    Item Boiler_Lockout_Code changed
then
    var int graphState = 0
    var int status = if(Boiler_Status_Code.state instanceof Number) (Boiler_Status_Code.state as Number).intValue else 0
    var int block  = if(Boiler_Blocking.state instanceof Number) (Boiler_Blocking.state as Number).intValue else 0
    var int lock   = if(Boiler_Lockout_Code.state instanceof Number) (Boiler_Lockout_Code.state as Number).intValue else 32767

    if (lock != 32767) {
        graphState = -2
    }
    else if (block != 0 && block != 32767) {
        graphState = -1
    }
    else if (status == 19) {
        graphState = 2
    }
    else if (status == 21 || status == 22 || status == 23) {
        graphState = 1
    }
    else {
        graphState = 0
    }

    if (Boiler_Graph_State.state != graphState) {
        Boiler_Graph_State.postUpdate(graphState)
    }
end