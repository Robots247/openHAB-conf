import org.openhab.core.model.script.ScriptServiceUtil

// ===================================================================================
// PROFESSIONAL OUTDOOR RESET (Max-Select Architecture)
// Features: Independent Calculation, Max-Select Arbitration, Integral Persistence
// Updated: Detailed Debugging Added
// ===================================================================================

// --- GLOBAL VARIABLES ---
var Number last_outdoor_smooth = 40.0 
var Number room_integral_mem = 0.0    // Persistent Memory for Room Feedback

// ===================================================================================
// RULE 1: INITIALIZATION
// ===================================================================================
rule "Initialize Tuning Parameters"
when
    System started
then
    // Initialize Defaults if NULL
    if (ODR_Slope.state == NULL || ODR_Slope.state == UNDEF) ODR_Slope.postUpdate(-1.1)
    if (ODR_Intercept.state == NULL || ODR_Intercept.state == UNDEF) ODR_Intercept.postUpdate(160.0)
    
    // Room Feedback: Tuned for Stability
    if (Room_Kp.state == NULL || Room_Kp.state == UNDEF) Room_Kp.postUpdate(5.0)  // Strong P-Term
    if (Room_Ki.state == NULL || Room_Ki.state == UNDEF) Room_Ki.postUpdate(0.05) // Slow I-Term
    
    logInfo("Boiler.Init", "ODR parameters initialized.")
end

// ===================================================================================
// RULE 2: CALCULATION LOOP (Runs every minute)
// ===================================================================================
rule "Calculate Outdoor Reset Target"
when
    Time cron "0 * * ? * *" 
then
    // ---------------------------------------------------------
    // 0. FETCH INPUTS
    // ---------------------------------------------------------
    val Number curveSlope = if(ODR_Slope.state instanceof Number) (ODR_Slope.state as Number).doubleValue else -1.1
    val Number curveIntercept = if(ODR_Intercept.state instanceof Number) (ODR_Intercept.state as Number).doubleValue else 160.0
    val Number Kp_room_val = if(Room_Kp.state instanceof Number) (Room_Kp.state as Number).doubleValue else 5.0
    val Number Ki_room_val = if(Room_Ki.state instanceof Number) (Room_Ki.state as Number).doubleValue else 0.05

    // Outdoor Temp Smoothing (Low Pass Filter: 5% New, 95% Old)
    var Number rawOutdoor = 32.0
    if (Outdoor_Temperature.state instanceof Number) {
        rawOutdoor = (Outdoor_Temperature.state as Number).doubleValue
    }
    last_outdoor_smooth = (0.05 * rawOutdoor) + (0.95 * last_outdoor_smooth)
    val Number outdoorInput = last_outdoor_smooth 

    // Zone Calls
    var boolean garageCall = (GAZV.state == ON)
    var boolean baseboardCall = (LRZV.state == ON || GBrZV.state == ON || BMTZV.state == ON || MRZV.state == ON)
    var boolean radiantCall = (KITRH.state == ON || DENRH.state == ON || MBaRH.state == ON || MBeRH.state == ON)

    // Boiler Busy State (for Integral freezing)
    var int bState = if(Boiler_Graph_State.state instanceof Number) (Boiler_Graph_State.state as Number).intValue else 0
    var boolean boilerIsBusy = (bState == 2 || bState < 0)
    
    // Room Error (Max error from all active Baseboard zones)
    var Number maxErrorHT = 0.0
    if (Boiler_Max_Error.state instanceof Number) {
        maxErrorHT = (Boiler_Max_Error.state as Number).doubleValue
    }

    logInfo("ODR_Debug", "========================================")
    logInfo("ODR_Debug", "   OUTDOOR RESET CALCULATION REPORT     ")
    logInfo("ODR_Debug", "========================================")
    logInfo("ODR_Debug", "INPUTS: Outdoor(Smooth)=" + String::format("%.1f", outdoorInput.doubleValue) + "F | Raw=" + rawOutdoor)
    logInfo("ODR_Debug", "CONFIG: Slope=" + curveSlope + " | Intercept=" + curveIntercept)

    // ---------------------------------------------------------
    // 1. CALCULATE INDIVIDUAL ZONE REQUIREMENTS
    // ---------------------------------------------------------
    
    // A. GARAGE REQUIREMENT (Steep Comfort Curve)
    var double reqGarage = 0.0
    if (garageCall) {
        val double gar_Intercept = 180.0
        val double gar_Slope = -0.7 // Steep slope
        reqGarage = gar_Intercept + (gar_Slope * outdoorInput.doubleValue)
        
        // Clamp for comfort (prevent cold blow) and equipment safety
        if (reqGarage < 145.0) reqGarage = 145.0
        if (reqGarage > 180.0) reqGarage = 180.0
        logInfo("ODR_Debug", "GARAGE: Active. Calc=" + String::format("%.1f", reqGarage) + "F (Comfort Curve)")
    } else {
        logInfo("ODR_Debug", "GARAGE: Inactive (0.0F)")
    }

    // B. BASEBOARD REQUIREMENT (ODR + Room Feedback)
    var double reqBaseboard = 0.0
    var double baseTarget = 0.0
    var double P_room = 0.0
    
    if (baseboardCall) {
        baseTarget = curveIntercept.doubleValue + (curveSlope.doubleValue * outdoorInput.doubleValue)
        
        // --- Room Feedback Logic ---
        P_room = Kp_room_val.doubleValue * maxErrorHT.doubleValue
        
        // Integral Accumulation (Smart Windup)
        if (!boilerIsBusy) {
            if (maxErrorHT.doubleValue > 0.5) {
                // If rooms are cold, accumulate boost
                room_integral_mem = room_integral_mem + (Ki_room_val.doubleValue * maxErrorHT.doubleValue)
            } else if (maxErrorHT.doubleValue < 0.2) {
                // If rooms are satisfied, FAST DECAY the boost
                room_integral_mem = room_integral_mem * 0.80 
            }
        }
        
        // Anti-Windup (Clamps)
        if (room_integral_mem > 15.0) room_integral_mem = 15.0
        if (room_integral_mem < -5.0) room_integral_mem = -5.0
        
        reqBaseboard = baseTarget + P_room + room_integral_mem.doubleValue
        
        // Baseboard Safety Clamps
        // LOWERED MIN CLAMP TO 110F to maximize condensing in shoulder season
        if (reqBaseboard > 175.0) reqBaseboard = 175.0
        if (reqBaseboard < 110.0) reqBaseboard = 110.0
        
        logInfo("ODR_Debug", "BASEBOARD: Active. MaxError=" + maxErrorHT + "F")
        logInfo("ODR_Debug", "   Math: Curve(" + String::format("%.1f", baseTarget) + ") + P(" + String::format("%.1f", P_room) + ") + I(" + String::format("%.1f", room_integral_mem.doubleValue) + ") = " + String::format("%.1f", reqBaseboard))
    }
    else {
        // If Baseboard is OFF, slowly decay memory
        room_integral_mem = room_integral_mem * 0.90
        logInfo("ODR_Debug", "BASEBOARD: Inactive. Memory Decay=" + String::format("%.1f", room_integral_mem.doubleValue))
    }

    // C. RADIANT REQUIREMENT (Mix-Feed Curve)
    // Caleffi Valve Requirement: Needs ~20F overhead for stability.
    // Minimum Supply Temp for valve stability is roughly 130F.
    var double reqRadiant = 0.0
    if (radiantCall) {
        val double rad_Intercept = 140.0 // Increased from 130 to give headroom
        val double rad_Slope = -0.5      // Shallower slope
        reqRadiant = rad_Intercept + (rad_Slope * outdoorInput.doubleValue)
        
        // Radiant Clamps
        // CLAMP: 130F Minimum to satisfy Caleffi mixing valve Delta-T requirement
        if (reqRadiant > 160.0) reqRadiant = 160.0
        if (reqRadiant < 130.0) reqRadiant = 130.0
        logInfo("ODR_Debug", "RADIANT: Active. Calc=" + String::format("%.1f", reqRadiant) + "F (Mix Valve Feed - Min 130F)")
    } else {
        logInfo("ODR_Debug", "RADIANT: Inactive (0.0F)")
    }

    // ---------------------------------------------------------
    // 2. MAX-SELECT ARBITRATION
    // ---------------------------------------------------------
    
    var double finalTarget = 0.0
    var String demandSource = "None"

    // Default winner is usually Baseboard or Radiant
    if (reqBaseboard >= reqRadiant) {
        finalTarget = reqBaseboard
        demandSource = "Baseboard (ODR)"
    } else {
        finalTarget = reqRadiant
        demandSource = "Radiant (Mix Overhead)"
    }
    
    // Garage Priority Override (if higher)
    if (reqGarage > finalTarget) {
        finalTarget = reqGarage
        demandSource = "Garage Priority"
    }
    
    // If no calls, target is 0
    if (!garageCall && !baseboardCall && !radiantCall) {
        finalTarget = 0.0
        demandSource = "No Demand"
    }

    // ---------------------------------------------------------
    // 3. POST UPDATES
    // ---------------------------------------------------------
    Boiler_Room_Integral.postUpdate(room_integral_mem)
    Boiler_Demand_Type.postUpdate(demandSource)
    Boiler_Target_Temp.postUpdate(finalTarget)
    
    logInfo("ODR_Debug", ">>> DECISION: " + demandSource + " WINS. Target=" + String::format("%.1f", finalTarget) + "F <<<")
    logInfo("ODR_Debug", "========================================")
end