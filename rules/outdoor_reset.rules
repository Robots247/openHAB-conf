import org.openhab.core.model.script.ScriptServiceUtil

// ===================================================================================
// OPTIMIZED OUTDOOR RESET & "WORST-CASE" FEEDBACK LOGIC
// ===================================================================================

// Global Variables
var Number last_outdoor_smooth = 40.0 // Seed default
var Number room_integral_mem = 0.0    // Local memory for integral

rule "Calculate Outdoor Reset Target"
when
    Time cron "0 * * ? * *" // Runs every 1 Minute (Aligned with thermal time constant)
then
    // 1. OUTDOOR SENSOR SMOOTHING
    // -------------------------------------------------------------------------------
    // Safety check for NULL outdoor sensor
    var Number rawOutdoor = 32.0
    if (Outdoor_Temperature.state instanceof Number) {
        rawOutdoor = (Outdoor_Temperature.state as Number).doubleValue
    }
    
    // EMA Filter (Alpha 0.05 = Heavy smoothing for massive thermal systems)
    // On a 1-minute loop, this alpha effectively averages the last ~20 minutes.
    last_outdoor_smooth = (0.05 * rawOutdoor) + (0.95 * last_outdoor_smooth)
    val Number outdoorInput = last_outdoor_smooth 

    // 2. CALCULATE "MAX ERROR" (The Driver)
    // -------------------------------------------------------------------------------
    
    var double maxErrorHT = 0.0
    var double maxErrorLT = 0.0
    
    // CORRECTION: Used Function2 (2 inputs, 1 output) instead of Function3
    val Functions$Function2<Object, Object, Double> calcError = [ Object setpointObj, Object actualObj |
        
        // Safety: Logic to handle NULL items without crashing
        if (setpointObj === null || actualObj === null) return 0.0
        if (setpointObj == NULL || actualObj == NULL) return 0.0
        if (setpointObj == UNDEF || actualObj == UNDEF) return 0.0

        var double sp = (setpointObj as Number).doubleValue
        var double act = (actualObj as Number).doubleValue
        
        var double err = sp - act
        if (err < 0) return 0.0
        return err
    ]

    // --- High Temp Zones ---
    if (LRZV.state == ON)   maxErrorHT = Math::max(maxErrorHT, calcError.apply(LR_Heating_TargetTemp.state, LRMS_Temp.state))
    if (GBrZV.state == ON)  maxErrorHT = Math::max(maxErrorHT, calcError.apply(GBr_Heating_TargetTemp.state, GBrMS_Temp.state))
    if (MRZV.state == ON)   maxErrorHT = Math::max(maxErrorHT, calcError.apply(MR_Heating_TargetTemp.state, MRMS_Temp.state))
    if (BMTZV.state == ON)  maxErrorHT = Math::max(maxErrorHT, calcError.apply(BMT_Heating_TargetTemp.state, BMTBrMS_Temp.state))
    
    // Garage: Only if Override is NOT active
    if (GAZV.state == ON && vGA_Heating_OFF_Override.state != ON) {
         maxErrorHT = Math::max(maxErrorHT, calcError.apply(GA_Heating_TargetTemp.state, GAMS_Temp.state))
    }

    // --- Low Temp Zones ---
    if (DENRH.state == ON) maxErrorLT = Math::max(maxErrorLT, calcError.apply(DEN_Heating_TargetTemp.state, DENMS_Temp.state))
    if (MBaRH.state == ON) maxErrorLT = Math::max(maxErrorLT, calcError.apply(MBe_Heating_TargetTemp.state, MBeMS_Temp.state)) 
    if (MBeRH.state == ON) maxErrorLT = Math::max(maxErrorLT, calcError.apply(MBe_Heating_TargetTemp.state, MBeMS_Temp.state))
    // Kitchen matches Den in your rules
    if (KITRH.state == ON) maxErrorLT = Math::max(maxErrorLT, calcError.apply(DEN_Heating_TargetTemp.state, DENMS_Temp.state)) 

    // Update the UI item for debugging
    Boiler_Max_Error.postUpdate(Math::max(maxErrorHT, maxErrorLT))

    // 3. ASSESS DEMAND WEIGHT (For Boiler limits)
    // -------------------------------------------------------------------------------
    var int zoneWeight = 0
    var boolean highTempCall = false
    var boolean lowTempCall = false

    if (LRZV.state == ON)   { zoneWeight += 20; highTempCall = true; }
    if (GBrZV.state == ON)  { zoneWeight += 15; highTempCall = true; }
    if (BMTZV.state == ON)  { zoneWeight += 15; highTempCall = true; }
    if (GAZV.state == ON)   { zoneWeight += 25; highTempCall = true; }
    if (MRZV.state == ON)   { zoneWeight += 5;  highTempCall = true; }

    if (KITRH.state == ON)  { zoneWeight += 10; lowTempCall = true; }
    if (DENRH.state == ON)  { zoneWeight += 10; lowTempCall = true; }
    if (MBaRH.state == ON)  { zoneWeight += 5;  lowTempCall = true; }
    if (MBeRH.state == ON)  { zoneWeight += 5;  lowTempCall = true; }

    if (zoneWeight > 100) zoneWeight = 100
    Boiler_Zone_Limit.postUpdate(zoneWeight)

    // 4. CALCULATE FINAL TARGET
    // -------------------------------------------------------------------------------
    var Number targetTemp = 0.0
    var String demandType = "None"
    
    // We prioritize High Temp. If both are calling, we must satisfy the High Temp requirement
    
    if (highTempCall) {
        demandType = "High Temp (PID)"
        
        // A. Base Curve (-1.1 Slope)
        var Number baseTarget = 180.0 + (-1.1 * outdoorInput)
        
        // B. Room PID (Driven by maxErrorHT)
        var Number error = maxErrorHT
        
        // P-Term: 4 degrees boost per degree of error (Instant)
        var Number P_room = 4.0 * error
        
        // I-Term: Adjusted for 1-minute loop
        // We want 0.5 degrees per minute. 
        // Multiplier increased from 0.125 (15s) to 0.5 (60s)
        if (error > 0.1) {
            room_integral_mem = room_integral_mem + (0.5 * error)
        } else {
            // Slowly bleed off integral if error is resolved
            // Adjusted decay: 0.98^4 â‰ˆ 0.92
            room_integral_mem = room_integral_mem * 0.92
        }
        
        // Anti-Windup
        if (room_integral_mem > 20) room_integral_mem = 20
        if (room_integral_mem < -5) room_integral_mem = -5 
        
        // Visualize Integral
        Boiler_Room_Integral.postUpdate(room_integral_mem)

        targetTemp = baseTarget + P_room + room_integral_mem
        
        // Clamps
        if (targetTemp > 180) targetTemp = 180
        if (targetTemp < 120) targetTemp = 120
        
    } else if (lowTempCall) {
        demandType = "Low Temp"
        // Radiant Curve (-0.5 Slope)
        var Number baseTarget = 120.0 + (-0.5 * outdoorInput)
        
        // Mild boost for Radiant
        var Number P_room = 2.0 * maxErrorLT
        
        targetTemp = baseTarget + P_room
        
        if (targetTemp > 120) targetTemp = 120
        if (targetTemp < 85) targetTemp = 85
        
        // Reset High Temp Integral
        room_integral_mem = 0.0
        Boiler_Room_Integral.postUpdate(0)
    } else {
        targetTemp = 0.0
        room_integral_mem = 0.0
    }

    Boiler_Demand_Type.postUpdate(demandType)
    Boiler_Target_Temp.postUpdate(targetTemp)
end