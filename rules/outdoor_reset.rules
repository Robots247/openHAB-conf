import org.openhab.core.model.script.ScriptServiceUtil

// ===================================================================================
// PROFESSIONAL OUTDOOR RESET MANAGER (ODR)
// Architecture: Max-Select Arbitration with Room Feedback Integration
// Updates: Radiant Cap Added (Prevent Windup against Mixing Valves)
// ===================================================================================

// --- GLOBAL VARIABLES ---
var double last_outdoor_smooth = 40.0 
var double room_integral_mem = 0.0    // Persistent Memory for Room Feedback

// ===================================================================================
// RULE 1: INITIALIZATION
// ===================================================================================
rule "Initialize ODR Parameters"
when
    System started
then
    // Initialize Defaults if NULL
    if (ODR_Slope.state == NULL || ODR_Slope.state == UNDEF) ODR_Slope.postUpdate(-1.1)
    if (ODR_Intercept.state == NULL || ODR_Intercept.state == UNDEF) ODR_Intercept.postUpdate(160.0)
    
    // Room Feedback: Tuned for Stability
    if (Room_Kp.state == NULL || Room_Kp.state == UNDEF) Room_Kp.postUpdate(3.0)  
    if (Room_Ki.state == NULL || Room_Ki.state == UNDEF) Room_Ki.postUpdate(0.05) 
    
    logInfo("ODR.Init", "Professional ODR parameters initialized.")
end

// ===================================================================================
// RULE 2: CALCULATION LOOP (Runs every minute)
// ===================================================================================
rule "Calculate Outdoor Reset Target"
when
    Time cron "0 * * ? * *" 
then
    // ---------------------------------------------------------
    // 0. FETCH & SANITIZE INPUTS
    // ---------------------------------------------------------
    val double curveSlope = if(ODR_Slope.state instanceof Number) (ODR_Slope.state as Number).doubleValue else -1.1
    val double curveIntercept = if(ODR_Intercept.state instanceof Number) (ODR_Intercept.state as Number).doubleValue else 160.0
    val double Kp_room_val = if(Room_Kp.state instanceof Number) (Room_Kp.state as Number).doubleValue else 3.0
    val double Ki_room_val = if(Room_Ki.state instanceof Number) (Room_Ki.state as Number).doubleValue else 0.05

    // OUTDOOR TEMP SMOOTHING
    var double rawOutdoor = 32.0
    if (Outdoor_Temperature.state instanceof Number) {
        rawOutdoor = (Outdoor_Temperature.state as Number).doubleValue
    }
    
    // Safety check for bad sensor data
    if (rawOutdoor > -50.0 && rawOutdoor < 120.0) {
        if (rawOutdoor < last_outdoor_smooth) {
            last_outdoor_smooth = (0.20 * rawOutdoor) + (0.80 * last_outdoor_smooth)
        } else {
            last_outdoor_smooth = (0.02 * rawOutdoor) + (0.98 * last_outdoor_smooth)
        }
    }
    val double outdoorInput = last_outdoor_smooth 

    // WWSD CHECK: 75F Threshold
    if (outdoorInput > 75.0) {
        if (Boiler_Target_Temp.state != 0) Boiler_Target_Temp.postUpdate(0)
        Boiler_Demand_Type.postUpdate("WWSD (Warm)")
        room_integral_mem = 0.0 
        return; 
    }

    // Zone Calls
    var boolean garageCall = (GAZV.state == ON)
    var boolean baseboardCall = (LRZV.state == ON || GBrZV.state == ON || BMTZV.state == ON || MRZV.state == ON)
    var boolean radiantCall = (KITRH.state == ON || DENRH.state == ON || MBaRH.state == ON || MBeRH.state == ON)

    // Boiler Busy State
    var int bState = if(Boiler_Graph_State.state instanceof Number) (Boiler_Graph_State.state as Number).intValue else 0
    var boolean boilerIsBusy = (bState == 2 || bState < 0) 
    
    // Room Error
    var double maxErrorHT = 0.0
    if (Boiler_Max_Error.state instanceof Number) {
        maxErrorHT = (Boiler_Max_Error.state as Number).doubleValue
    }
    
    // SAFETY CLAMP: Input Error
    // If error is > 10F, it's likely a glitch. Clamp effective error.
    var double effectiveError = maxErrorHT
    if (effectiveError > 10.0) effectiveError = 10.0

    // ---------------------------------------------------------
    // 1. CALCULATE INDIVIDUAL ZONE REQUIREMENTS
    // ---------------------------------------------------------
    
    // A. GARAGE REQUIREMENT
    var double reqGarage = 0.0
    if (garageCall) {
        val double gar_Intercept = 180.0
        val double gar_Slope = -0.7 
        reqGarage = gar_Intercept + (gar_Slope * outdoorInput)
        if (reqGarage < 145.0) reqGarage = 145.0
        if (reqGarage > 180.0) reqGarage = 180.0
    }

    // B. BASEBOARD REQUIREMENT (ODR + PID Room Feedback)
    var double reqBaseboard = 0.0
    var double baseTarget = 0.0
    var double P_room = 0.0
    
    if (baseboardCall) {
        baseTarget = curveIntercept + (curveSlope * outdoorInput)
        
        P_room = Kp_room_val * effectiveError
        
        // AUTHORITY CLAMP (TIGHTENED to 10F)
        if (P_room > 10.0) P_room = 10.0
        
        // Integral Logic
        if (!boilerIsBusy) {
            // Anti-Windup: Only integrate if error is reasonable (< 5F)
            if (effectiveError > 0.5 && effectiveError < 5.0) {
                room_integral_mem = room_integral_mem + (Ki_room_val * effectiveError)
            } else if (effectiveError <= 0.2) {
                room_integral_mem = room_integral_mem * 0.70 
            } else if (effectiveError >= 5.0) {
                // Decay integral if error is massive (prevents runaway)
                room_integral_mem = room_integral_mem * 0.99
            }
        }
        
        // Clamp I-Term
        if (room_integral_mem > 5.0) room_integral_mem = 5.0
        if (room_integral_mem < -5.0) room_integral_mem = -5.0
        
        reqBaseboard = baseTarget + P_room + room_integral_mem
        
        if (reqBaseboard > 175.0) reqBaseboard = 175.0
        if (reqBaseboard < 110.0) reqBaseboard = 110.0
    }
    else {
        room_integral_mem = room_integral_mem * 0.90
    }

    // C. RADIANT REQUIREMENT
    var double reqRadiant = 0.0
    if (radiantCall) {
        val double rad_Intercept = 140.0 
        val double rad_Slope = -0.5      
        reqRadiant = rad_Intercept + (rad_Slope * outdoorInput)
        
        if (reqRadiant > 160.0) reqRadiant = 160.0
        if (reqRadiant < 130.0) reqRadiant = 130.0
    }

    // ---------------------------------------------------------
    // 2. MAX-SELECT ARBITRATION
    // ---------------------------------------------------------
    
    var double finalTarget = 0.0
    var String demandSource = "None"

    if (reqBaseboard >= reqRadiant) {
        finalTarget = reqBaseboard
        demandSource = "Baseboard"
    } else {
        finalTarget = reqRadiant
        demandSource = "Radiant"
    }
    
    // RADIANT CAP (The Fix for Mixing Valves)
    // If Radiant Wins, we MUST cap the target at what the mixing valve can handle (e.g. 145F).
    // Sending 170F is useless if the valve clips it to 120F.
    if (demandSource == "Radiant" && finalTarget > 145.0) {
        finalTarget = 145.0
    }

    if (reqGarage > finalTarget) {
        finalTarget = reqGarage
        demandSource = "Garage"
    }
    
    if (!garageCall && !baseboardCall && !radiantCall) {
        finalTarget = 0.0
        demandSource = "Standby"
    }

    // ---------------------------------------------------------
    // 3. EXECUTION & LOGGING
    // ---------------------------------------------------------
    Boiler_Room_Integral.postUpdate(room_integral_mem)
    Boiler_Demand_Type.postUpdate(demandSource)
    Boiler_Target_Temp.postUpdate(finalTarget)
    
    if (finalTarget > 0) {
        logInfo("ODR.Diagnostic", 
            "Out:" + String::format("%.1f", outdoorInput) + 
            "|Base:" + String::format("%.1f", baseTarget) + 
            "|BoostP:" + String::format("%.1f", P_room) + 
            "|BoostI:" + String::format("%.1f", room_integral_mem) +
            "|Err:" + String::format("%.1f", maxErrorHT) + 
            "|WIN:" + demandSource +
            "|FINAL:" + String::format("%.1f", finalTarget)
        )
    }
end