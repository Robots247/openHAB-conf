import org.openhab.core.model.script.ScriptServiceUtil

// ===================================================================================
// PROFESSIONAL OUTDOOR RESET MANAGER (ODR)
// Architecture: Max-Select Arbitration with Shared Room Feedback
// Updates: Radiant now uses ODR Curve + Valve Overhead (Prevents overheating on mild days)
//          Added Room Feedback Trend Freezing and D-Term for stability.
// ===================================================================================

// --- GLOBAL VARIABLES ---
var double last_outdoor_smooth = 40.0 
var double room_integral_mem = 0.0    // Persistent Memory for PID
var double last_effective_error = 0.0 // To track error trend

// ===================================================================================
// RULE 1: INITIALIZATION
// ===================================================================================
rule "Initialize ODR Parameters"
when
    System started
then
    // Baseboard/High Temp Curve
    if (ODR_Slope.state == NULL || ODR_Slope.state == UNDEF) ODR_Slope.postUpdate(-1.2)
    if (ODR_Intercept.state == NULL || ODR_Intercept.state == UNDEF) ODR_Intercept.postUpdate(170.0)
    
    // Radiant Low Temp Curve (Internal Params)
    // You can expose these to Items if you want UI control later
    // Default: At 0F Out -> 130F Mix. At 70F Out -> 88F Mix.
    
    // Standard Room Feedback (Baseboard/Air)
    if (Room_Baseboard_Kp.state == NULL || Room_Baseboard_Kp.state == UNDEF) Room_Baseboard_Kp.postUpdate(3.0)  
    if (Room_Baseboard_Ki.state == NULL || Room_Baseboard_Ki.state == UNDEF) Room_Baseboard_Ki.postUpdate(0.05) 
    
    // Radiant Specific Feedback
    if (Room_Radiant_Kp.state == NULL || Room_Radiant_Kp.state == UNDEF) Room_Radiant_Kp.postUpdate(6.0)
    if (Room_Radiant_Ki.state == NULL || Room_Radiant_Ki.state == UNDEF) Room_Radiant_Ki.postUpdate(0.20)
    
    // Initialize Radiant Target (Now used as a Max Limit)
    if (ODR_Radiant_Target.state == NULL || ODR_Radiant_Target.state == UNDEF) ODR_Radiant_Target.postUpdate(140.0)

    logInfo("ODR.Init", "Professional ODR parameters initialized.")
end

// ===================================================================================
// RULE 2: CALCULATION LOOP (Runs every minute)
// ===================================================================================
rule "Calculate Outdoor Reset Target"
when
    Time cron "0 * * ? * *" 
then
    // ---------------------------------------------------------
    // 0. FETCH & SANITIZE INPUTS
    // ---------------------------------------------------------
    val double curveSlope = if(ODR_Slope.state instanceof Number) (ODR_Slope.state as Number).doubleValue else -1.2
    val double curveIntercept = if(ODR_Intercept.state instanceof Number) (ODR_Intercept.state as Number).doubleValue else 170.0
    
    // Standard Gains (Baseboard)
    val double Kp_std = if(Room_Baseboard_Kp.state instanceof Number) (Room_Baseboard_Kp.state as Number).doubleValue else 3.0
    val double Ki_std = if(Room_Baseboard_Ki.state instanceof Number) (Room_Baseboard_Ki.state as Number).doubleValue else 0.05
    
    // Radiant Gains
    val double Kp_rad = if(Room_Radiant_Kp.state instanceof Number) (Room_Radiant_Kp.state as Number).doubleValue else 6.0
    val double Ki_rad = if(Room_Radiant_Ki.state instanceof Number) (Room_Radiant_Ki.state as Number).doubleValue else 0.20

    // OUTDOOR TEMP SMOOTHING
    var double rawOutdoor = 32.0
    if (Outdoor_Temperature.state instanceof Number) {
        rawOutdoor = (Outdoor_Temperature.state as Number).doubleValue
    }
    
    if (rawOutdoor > -50.0 && rawOutdoor < 120.0) {
        if (rawOutdoor < last_outdoor_smooth) {
            last_outdoor_smooth = (0.20 * rawOutdoor) + (0.80 * last_outdoor_smooth)
        } else {
            last_outdoor_smooth = (0.02 * rawOutdoor) + (0.98 * last_outdoor_smooth)
        }
    }
    val double outdoorInput = last_outdoor_smooth 

    // WWSD CHECK
    if (outdoorInput > 75.0) {
        if (Boiler_Target_Temp.state != 0) Boiler_Target_Temp.postUpdate(0)
        Boiler_Demand_Type.postUpdate("WWSD (Warm)")
        room_integral_mem = 0.0 
        return;
    }

    // Zone Calls
    var boolean garageCall = (GAZV.state == ON)
    var boolean baseboardCall = (LRZV.state == ON || GBrZV.state == ON || BMTZV.state == ON || MRZV.state == ON)
    var boolean radiantCall = (KITRH.state == ON || DENRH.state == ON || MBaRH.state == ON || MBeRH.state == ON)

    // Boiler Busy State
    var int bState = if(Boiler_Graph_State.state instanceof Number) (Boiler_Graph_State.state as Number).intValue else 0
    var boolean boilerIsBusy = (bState == 2 || bState < 0) 
    
    // ---------------------------------------------------------
    // 0A. GET MAX ROOM ERROR (From thermostat.rules)
    // ---------------------------------------------------------
    var double effectiveError = 0.0
    if (Boiler_Max_Error.state instanceof Number) {
        effectiveError = (Boiler_Max_Error.state as Number).doubleValue
    }
    if (effectiveError > 10.0) effectiveError = 10.0
    if (effectiveError < 0.0) effectiveError = 0.0

    // ---------------------------------------------------------
    // 0B. CALCULATE SHARED ROOM CORRECTION (DYNAMIC PID)
    // ---------------------------------------------------------
    
    var double active_Kp = Kp_std
    var double active_Ki = Ki_std
    // Use a fixed D-Term for now, can be exposed later
    var double active_Kd = 10.0 
    
    if (radiantCall) {
        active_Kp = Kp_rad 
        active_Ki = Ki_rad 
        // Radiant needs stronger D action due to thermal mass lag
        active_Kd = 20.0 
    }
    
    // 1. Proportional Term (P)
    var double P_room = active_Kp * effectiveError
    if (P_room > 20.0) P_room = 20.0 
    
    // 2. Derivative Term (D)
    // Calculate rate of change (Error Delta per minute)
    var double errorDelta = effectiveError - last_effective_error
    // If error is shrinking (errorDelta < 0), D_room will be negative, braking the output.
    var double D_room = active_Kd * errorDelta
    
    // 3. Integral Term (I) with DYNAMIC RANGE & TREND FREEZING
    var double integral_limit_high = 5.0
    if (effectiveError > 1.0) integral_limit_high = 30.0 // Allow wind-up for deep recovery
    
    if (baseboardCall || radiantCall) {
        if (!boilerIsBusy) {
            // TREND FREEZING Logic:
            // If the error is decreasing (we are winning), STOP integrating.
            // Only integrate if error is steady or growing.
            var boolean isRecovering = (errorDelta < -0.05) // Error shrinking by >0.05F/min
            
            if (effectiveError > 0.5 && !isRecovering) {
                // Accumulate only if not recovering
                room_integral_mem = room_integral_mem + (active_Ki * effectiveError)
            } else if (effectiveError < 0.2) {
                // Decay logic (Deadband widened from <0.2 to include holding range)
                room_integral_mem = room_integral_mem * 0.70 
            }
            // HOLDING: If 0.2 <= error <= 0.5 OR isRecovering, do nothing (Hold I value)
        }
        if (room_integral_mem > integral_limit_high) room_integral_mem = integral_limit_high
        if (room_integral_mem < -5.0) room_integral_mem = -5.0
    }
    else {
        room_integral_mem = room_integral_mem * 0.90
    }
    
    // Update State for next loop
    last_effective_error = effectiveError
    
    var double totalRoomCorrection = P_room + room_integral_mem + D_room
    
    // Prevent negative correction from fighting the ODR base too much
    if (totalRoomCorrection < -5.0) totalRoomCorrection = -5.0

    // ---------------------------------------------------------
    // 1. CALCULATE INDIVIDUAL ZONE REQUIREMENTS
    // ---------------------------------------------------------
    
    // A. GARAGE
    var double reqGarage = 0.0
    if (garageCall) {
        val double gar_Intercept = 180.0
        val double gar_Slope = -0.7 
        reqGarage = gar_Intercept + (gar_Slope * outdoorInput)
        if (reqGarage < 145.0) reqGarage = 145.0
        if (reqGarage > 180.0) reqGarage = 180.0
    }

    // B. BASEBOARD REQUIREMENT (High Temp ODR)
    var double reqBaseboard = 0.0
    var double baseTarget = 0.0
    
    baseTarget = curveIntercept + (curveSlope * outdoorInput)
    
    if (baseboardCall) {
        reqBaseboard = baseTarget + totalRoomCorrection 
        
        if (reqBaseboard > 180.0) reqBaseboard = 180.0 
        if (reqBaseboard < 110.0) reqBaseboard = 110.0
    }

    // C. RADIANT REQUIREMENT (Low Temp ODR)
    var double reqRadiant = 0.0
    var double radiantBase = 0.0
    
    // FIXED: Calculate Radiant ODR Curve (Lower Slope)
    // Slope -0.6 is typical for radiant (vs -1.2 for baseboard)
    // Intercept 130 means at 0F outside, we want 130F mixed water
    val double rad_Slope = -0.6 
    val double rad_Intercept = 130.0 
    
    radiantBase = rad_Intercept + (rad_Slope * outdoorInput)
    
    if (radiantCall) {
        // CALEFFI OVERHEAD
        val double mixingValveDelta = 27.0
        
        // 1. Apply PID to the Radiant Curve
        var double mixedTarget = radiantBase + totalRoomCorrection
        
        // 2. Clamp Mixed Target (Floor Safety)
        if (mixedTarget > 140.0) mixedTarget = 140.0 // Never ask for >140F Mixed
        if (mixedTarget < 85.0) mixedTarget = 85.0   // Min Floor Temp
        
        // 3. Add Valve Overhead
        reqRadiant = mixedTarget + mixingValveDelta
        
        // 4. Absolute Ceiling for Boiler Target in Radiant Mode
        if (reqRadiant > 170.0) reqRadiant = 170.0
    }

    // ---------------------------------------------------------
    // 2. MAX-SELECT ARBITRATION
    // ---------------------------------------------------------
    
    var double finalTarget = 0.0
    var String demandSource = "None"

    if (reqBaseboard >= reqRadiant) {
        finalTarget = reqBaseboard
        demandSource = "Baseboard"
    } else {
        finalTarget = reqRadiant
        demandSource = "Radiant"
    }
    
    if (reqGarage > finalTarget) {
        finalTarget = reqGarage
        demandSource = "Garage"
    }
    
    if (!garageCall && !baseboardCall && !radiantCall) {
        finalTarget = 0.0
        demandSource = "Standby"
    }

    // ---------------------------------------------------------
    // 3. EXECUTION & LOGGING (UPDATED WITH SLEW RATE LIMITER)
    // ---------------------------------------------------------
    
    // NEW: SLEW RATE LIMITER
    // Prevents "Teleporting" Targets when arbitration switches between Zones
    var double currentTarget = 0.0
    if (Boiler_Target_Temp.state instanceof Number) currentTarget = (Boiler_Target_Temp.state as Number).doubleValue
    
    // Only apply ramping if the boiler is ALREADY active (> 80F).
    // This allows instant startup from Standby (0 -> 140), but smooths transitions (130 -> 145).
    if (currentTarget > 80.0 && finalTarget > 80.0) {
        var double max_step = 2.0 // Max change per minute
        var double diff = finalTarget - currentTarget
        
        if (diff > max_step) {
             finalTarget = currentTarget + max_step
        } else if (diff < -max_step) {
             finalTarget = currentTarget - max_step
        }
    }

    Boiler_Room_Integral.postUpdate(room_integral_mem)
    Boiler_Demand_Type.postUpdate(demandSource)
    Boiler_Target_Temp.postUpdate(finalTarget)
    
    // === NEW: PID Diagnostic Updates ===
    Boiler_Room_P.postUpdate(P_room)
    Boiler_Room_I.postUpdate(room_integral_mem)
    Boiler_Room_D.postUpdate(D_room)
    
    try { ODR_Base_Target.postUpdate(baseTarget) } catch(Exception e) {}
    try { ODR_Req_Baseboard.postUpdate(reqBaseboard) } catch(Exception e) {}
    try { ODR_Req_Radiant.postUpdate(reqRadiant) } catch(Exception e) {}
    
    if (finalTarget > 0) {
        logInfo("ODR.Diagnostic", 
            "Out:" + String::format("%.1f", outdoorInput) + 
            "|Base:" + String::format("%.1f", baseTarget) + 
            "|RadBase:" + String::format("%.1f", radiantBase) +
            "|Boost:" + String::format("%.1f", totalRoomCorrection) + 
            "|P:" + String::format("%.1f", P_room) +
            "|I:" + String::format("%.1f", room_integral_mem) +
            "|D:" + String::format("%.1f", D_room) +
            "|ReqRad:" + String::format("%.1f", reqRadiant) + 
            "|WIN:" + demandSource +
            "|FINAL:" + String::format("%.1f", finalTarget)
         )
    }
end