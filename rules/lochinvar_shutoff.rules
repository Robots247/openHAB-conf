import org.openhab.core.model.script.ScriptServiceUtil

// ===================================================================================
// INTELLIGENT BOILER SHUTOFF & ENERGY MONITORING
// ===================================================================================

// Global State
var long block_end_time = 0

// 1. INITIALIZE TUNING DEFAULTS (System Start)
rule "Initialize Shutoff Parameters"
when
    System started
then
    if (Boiler_SmartOverrun_Enable.state == NULL) Boiler_SmartOverrun_Enable.postUpdate(OFF) 
    if (Boiler_Overrun_Threshold.state == NULL) Boiler_Overrun_Threshold.postUpdate(6.0)     
    if (Boiler_Block_Time.state == NULL) Boiler_Block_Time.postUpdate(10)                    
    if (Boiler_Rescue_Threshold.state == NULL) Boiler_Rescue_Threshold.postUpdate(15.0)      
    
    // Default Flow Estimates
    if (Flow_GPM_System.state == NULL) Flow_GPM_System.postUpdate(4.0)   
    if (Flow_GPM_Radiant.state == NULL) Flow_GPM_Radiant.postUpdate(2.5) 
    
    logInfo("Boiler.Shutoff", "Shutoff & Energy parameters initialized.")
end

// 2. MAIN MONITOR LOOP (Runs every 15s)
rule "Boiler Supervisor Loop"
when
    Time cron "0/15 * * * * ?" 
then
    // A. CALCULATE VIRTUAL FLOW & BTU
    // -------------------------------------------------------------------------------
    var double current_gpm = 0.0
    
    var double gpm_sys = if(Flow_GPM_System.state instanceof Number) (Flow_GPM_System.state as Number).doubleValue else 4.0
    var double gpm_rad = if(Flow_GPM_Radiant.state instanceof Number) (Flow_GPM_Radiant.state as Number).doubleValue else 2.5
    
    if (SysPump.state == ON) current_gpm = current_gpm + gpm_sys
    if (RHP.state == ON) current_gpm = current_gpm + gpm_rad
    
    Boiler_Est_Flow.postUpdate(current_gpm)
    
    // Calculate BTU: (GPM * DeltaT * 500)
    var double delta_t = if(Lochinvar_DeltaT.state instanceof Number) (Lochinvar_DeltaT.state as Number).doubleValue else 0.0
    if (delta_t < 0) delta_t = 0
    
    var double btu_hr = current_gpm * delta_t * 500.0
    Boiler_Output_BTU.postUpdate(btu_hr)

    // B. OVERRUN SUPERVISOR
    // -------------------------------------------------------------------------------
    var Number supply = if(System_Supply_Temp.state instanceof Number) (System_Supply_Temp.state as Number).doubleValue else 0.0
    var Number target = if(Boiler_Target_Temp.state instanceof Number) (Boiler_Target_Temp.state as Number).doubleValue else 0.0
    var Number fireRate = if(Boiler_Firing_Rate.state instanceof Number) (Boiler_Firing_Rate.state as Number).doubleValue else 0.0
    
    var double ovr_thresh = (Boiler_Overrun_Threshold.state as Number).doubleValue
    var double res_thresh = (Boiler_Rescue_Threshold.state as Number).doubleValue
    var int block_min = (Boiler_Block_Time.state as Number).intValue

    // --- DECISION LOGIC ---

    // 1. Are we currently in a "Timer Block"?
    // JODA FIX: Use .millis instead of .toInstant.toEpochMilli
    var boolean timer_active = (now.millis < block_end_time)

    // 2. Is the Overrun Condition met right now? (Rate low & Temp High)
    // Note: We include rate < 21 to catch idling, but if rate is 0 (already blocked), we still check temp.
    var boolean overrun_condition = (supply > (target + ovr_thresh)) && (fireRate < 21.0)
    
    // 3. Has the temp dropped enough to release a Normal Block? (Simple Hysteresis)
    var boolean release_condition = (supply <= target)

    // --- STATE MACHINE ---

    if (Boiler_Block_Active.state == ON) {
        // == WE ARE CURRENTLY BLOCKED ==
        
        if (timer_active) {
            // CASE A: SMART BLOCK (Timer Running)
            var double deficit = target - supply
            
            if (deficit > res_thresh) {
                // Rescue! House is crashing.
                block_end_time = 0
                Boiler_Block_Active.postUpdate(OFF)
                Boiler_Block_Status.postUpdate("RESCUE Activated")
                logInfo("Boiler.Shutoff", "RESCUE: Block broken due to demand spike.")
            } else {
                // Keep Waiting
                // JODA FIX: Use .millis for time math
                var long time_left_ms = block_end_time - now.millis
                var int time_left_min = (time_left_ms / 60000).intValue + 1
                Boiler_Block_Status.postUpdate("Smart Block: " + time_left_min + "m left")
                Boiler_Block_Timer_Rem.postUpdate(time_left_min)
            }
        } 
        else {
            // CASE B: NORMAL BLOCK (Or Smart Timer Expired)
            
            if (Boiler_SmartOverrun_Enable.state == ON) {
                // If Smart Mode is ON and timer is done -> Release.
                Boiler_Block_Active.postUpdate(OFF)
                Boiler_Block_Status.postUpdate("Monitoring")
                Boiler_Block_Timer_Rem.postUpdate(0)
            } else {
                // If Smart Mode is OFF -> We are in Standard Hysteresis.
                // We hold the block until Supply drops back to Target.
                if (release_condition) {
                    Boiler_Block_Active.postUpdate(OFF)
                    Boiler_Block_Status.postUpdate("Monitoring")
                } else {
                    Boiler_Block_Status.postUpdate("Limit Reached: Cooling to " + target.intValue)
                }
            }
        }
    } 
    else {
        // == WE ARE CURRENTLY RUNNING ==
        
        if (overrun_condition) {
            // TRIGGER SHUTDOWN
            Boiler_Block_Active.postUpdate(ON)
            
            if (Boiler_SmartOverrun_Enable.state == ON) {
                // Smart Mode: Start the Timer
                // JODA FIX: Use .millis directly on the DateTime object
                block_end_time = now.plusMinutes(block_min).millis
                
                Boiler_Block_Status.postUpdate("Overrun Detected: Smart Block Started")
                logInfo("Boiler.Shutoff", "SMART BLOCK: Rate " + fireRate + "% | Supply " + supply + " > " + (target+ovr_thresh))
            } else {
                // Normal Mode: Just Block (Latch until Release Condition)
                Boiler_Block_Status.postUpdate("Overrun Detected: Limit Cooling")
                logInfo("Boiler.Shutoff", "NORMAL BLOCK: Limit reached. Shutting down.")
            }
        } else {
            // Normal Operation
            Boiler_Block_Status.postUpdate("Monitoring")
            Boiler_Block_Timer_Rem.postUpdate(0)
        }
    }
end