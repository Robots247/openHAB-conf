import org.openhab.core.model.script.ScriptServiceUtil

// ===================================================================================
// INTELLIGENT BOILER SHUTOFF & ENERGY MONITORING (BMS SUPERVISOR)
// ===================================================================================

// Global State
var long block_end_time = 0

// 1. INITIALIZE TUNING DEFAULTS (System Start)
rule "Initialize Shutoff Parameters"
when
    System started
then
    if (Boiler_SmartOverrun_Enable.state == NULL) Boiler_SmartOverrun_Enable.postUpdate(ON) // Default ON for protection
    if (Boiler_Overrun_Threshold.state == NULL) Boiler_Overrun_Threshold.postUpdate(6.0)    // Shutoff if Supply > Target + 6F 
    if (Boiler_Block_Time.state == NULL) Boiler_Block_Time.postUpdate(15)                   // 15 Minute Penalty Box
    if (Boiler_Rescue_Threshold.state == NULL) Boiler_Rescue_Threshold.postUpdate(8.0)      // Rescue if Supply < Target - 8F
    
    // NEW: Release Hysteresis (Prevents "Bounce" starts)
    if (Boiler_Release_Diff.state == NULL) Boiler_Release_Diff.postUpdate(4.0)

    // Default Flow Estimates
    if (Flow_GPM_System.state == NULL) Flow_GPM_System.postUpdate(4.0)   
    if (Flow_GPM_Radiant.state == NULL) Flow_GPM_Radiant.postUpdate(2.5) 
    
    logInfo("Boiler.Shutoff", "Shutoff & Energy parameters initialized.")
end

// 2. MAIN MONITOR LOOP (Runs every 15s)
rule "Boiler Supervisor Loop"
when
    Time cron "0/15 * * * * ?" 
then
    // GUARD: Maintenance Mode
    if (System_Maintenance_Mode.state == ON) {
        if (Boiler_Block_Active.state == ON) {
            Boiler_Block_Active.postUpdate(OFF) // Clear block
            block_end_time = 0 // Reset timer
            Boiler_Block_Status.postUpdate("Maintenance Mode Active")
        }
        return;
    }

    // SAFETY CHECK: Ensure critical sensors are online
    if (System_Supply_Temp.state == NULL || Boiler_Target_Temp.state == NULL || Boiler_Inlet_Temp.state == NULL) return;

    // --- FETCH VALUES ---
    var double supply = (System_Supply_Temp.state as Number).doubleValue
    var double inlet = (Boiler_Inlet_Temp.state as Number).doubleValue
    var double target = (Boiler_Target_Temp.state as Number).doubleValue
    var double fireRate = if(Boiler_Firing_Rate.state instanceof Number) (Boiler_Firing_Rate.state as Number).doubleValue else 0.0
    var double Boiler_outlet_Temp_val = (Boiler_Outlet_Temp.state as Number).doubleValue
    // Calculate Delta T Real-Time (Supply - Inlet)
    //updated to calculate real delta t for boiler, not for boilervstank
    var double real_delta_t = Boiler_outlet_Temp_val - inlet
    // Update the Item for Visibility
    //Lochinvar_DeltaT.postUpdate(real_delta_t)

    // A. ENERGY & EFFICIENCY CALCULATION
    // -------------------------------------------------------------------------------
    var double current_gpm = 0.0
    var double gpm_sys = if(Flow_GPM_System.state instanceof Number) (Flow_GPM_System.state as Number).doubleValue else 4.0
    var double gpm_rad = if(Flow_GPM_Radiant.state instanceof Number) (Flow_GPM_Radiant.state as Number).doubleValue else 2.5
    
    if (SysPump.state == ON) current_gpm = current_gpm + gpm_sys
    if (RHP.state == ON) current_gpm = current_gpm + gpm_rad
    
    Boiler_Est_Flow.postUpdate(current_gpm)
    
    // BTU Calc: GPM * DeltaT * 500
    // Use Math.max to prevent negative BTU if sensors drift
    var double btu_hr = current_gpm * Math.max(0, real_delta_t) * 500.0
    Boiler_Output_BTU.postUpdate(btu_hr)

    // --- BMS EFFICIENCY SUPERVISOR ---
    // Monitor Condensing Status
    if (fireRate > 0) {
        if (inlet > 135.0) {
            logInfo("BMS.Efficiency", "NON-CONDENSING ALERT: Inlet " + inlet + "F. Efficiency dropping.")
        }
        
        // Monitor Delta-T Health
        // Use Item if exists, otherwise default to 20.0 (Professional Standard)
        var double minDeltaT = 20.0
        // Uncomment below if you create the item:
        // if (Boiler_Min_DeltaT.state instanceof Number) minDeltaT = (Boiler_Min_DeltaT.state as Number).doubleValue

        // If Delta T < 20F while firing, we are pumping too fast or firing too hard (Short Cycle Risk)
        if (real_delta_t < minDeltaT) {
             logInfo("BMS.Efficiency", "LOW DELTA-T WARNING: " + String::format("%.1f", real_delta_t) + "F (Target > " + minDeltaT + "F). System is saturated.")
             // FUTURE UPGRADE: This is where you would command the pump to slow down 
             // or forcefully reduce the firing rate limit.
        }
    }

    // B. OVERRUN LOGIC (Existing Logic)
    // -------------------------------------------------------------------------------
    
    var double ovr_thresh = if(Boiler_Overrun_Threshold.state instanceof Number) (Boiler_Overrun_Threshold.state as Number).doubleValue else 6.0
    var double res_thresh = if(Boiler_Rescue_Threshold.state instanceof Number) (Boiler_Rescue_Threshold.state as Number).doubleValue else 8.0
    var double rel_diff   = if(Boiler_Release_Diff.state instanceof Number) (Boiler_Release_Diff.state as Number).doubleValue else 4.0
    var int block_min = if(Boiler_Block_Time.state instanceof Number) (Boiler_Block_Time.state as Number).intValue else 15

    // 1. Timer Active?
    var boolean timer_active = (now.millis < block_end_time)

    // 2. Overrun Condition: (Temp High AND Fire Rate Minimum)
    var boolean overrun_condition = (supply > (target + ovr_thresh)) && (fireRate < 22.0)
    
    // 3. Release Condition: (Supply has dropped BELOW Target - Differential)
    var boolean release_condition = (supply <= (target - rel_diff))

    // --- STATE MACHINE ---

    if (Boiler_Block_Active.state == ON) {
        // == WE ARE CURRENTLY BLOCKED ==
        
        var double deficit = target - supply

        // GLOBAL RESCUE CHECK
        if (deficit > res_thresh) {
            block_end_time = 0
            Boiler_Block_Active.postUpdate(OFF)
            Boiler_Block_Status.postUpdate("RESCUE Activated")
            logInfo("Boiler.Shutoff", "RESCUE: Block broken due to demand spike. Deficit: " + deficit)
            return; 
        }

        if (timer_active && Boiler_SmartOverrun_Enable.state == ON) {
            // CASE A: SMART BLOCK (Timer Running)
            var long time_left_ms = block_end_time - now.millis
            var int time_left_min = (time_left_ms / 60000).intValue + 1
            Boiler_Block_Status.postUpdate("Smart Block: " + time_left_min + "m left")
            Boiler_Block_Timer_Rem.postUpdate(time_left_min)
        } 
        else {
            // CASE B: NORMAL BLOCK / TIMER EXPIRED
            if (release_condition) {
                Boiler_Block_Active.postUpdate(OFF)
                Boiler_Block_Status.postUpdate("Monitoring")
                Boiler_Block_Timer_Rem.postUpdate(0)
                logInfo("Boiler.Shutoff", "BLOCK RELEASED: Temp cooled to " + supply)
            } else {
                Boiler_Block_Status.postUpdate("Cooling: " + supply.intValue + " > " + (target - rel_diff).intValue)
                Boiler_Block_Timer_Rem.postUpdate(0)
            }
        }
    } 
    else {
        // == WE ARE CURRENTLY RUNNING ==
        
        if (overrun_condition) {
            // TRIGGER SHUTDOWN
            Boiler_Block_Active.postUpdate(ON)
            
            if (Boiler_SmartOverrun_Enable.state == ON) {
                block_end_time = now.plusMinutes(block_min).millis
                Boiler_Block_Status.postUpdate("Overrun: Smart Block Started")
                logInfo("Boiler.Shutoff", "SMART BLOCK: Rate " + fireRate + "% | Supply " + supply + " > Limit")
            } else {
                Boiler_Block_Status.postUpdate("Overrun: Limit Cooling")
                logInfo("Boiler.Shutoff", "NORMAL BLOCK: Supply " + supply + " > Limit")
            }
        } else {
            Boiler_Block_Status.postUpdate("Monitoring")
            Boiler_Block_Timer_Rem.postUpdate(0)
        }
    }
end