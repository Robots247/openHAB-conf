import org.eclipse.smarthome.model.script.ScriptServiceUtil
import java.util.Map

// ===================================================================================
// PROFESSIONAL THERMOSTAT ENGINE (Universal State Machine)
// Architecture: Group-Based Triggers, Centralized Logic, Dynamic Actuation
// Updates: Fully Compatible with 'heating_mode.items' naming conventions
// Compatibility: OpenHAB 2.5 (Eclipse Smarthome)
// ===================================================================================

// --- GLOBAL VARIABLES ---
val String filename = "Thermostat.Engine"
var Timer RHP_timer = null
var Timer SYSPump_timer = null

// Runtime Tracking Map
val Map<String, Long> lastOnTimes = newHashMap

// CONFIGURATION
val long MIN_RUN_TIME = 900000 // 15 Minutes (Wax Valve Protection)

// --- MAPPING CONFIGURATION ---

// 1. ACTUATORS (Room Prefix -> Switch Item)
val Map<String, String> roomActuators = newHashMap(
    "DEN" -> "DENRH",
    "MBa" -> "MBaRH",
    "MBe" -> "MBeRH",
    "LR"  -> "LRZV",
    "GBr" -> "GBrZV",
    "MR"  -> "MRZV",
    "BMT" -> "BMTZV",
    "GA"  -> "GAZV"
)

// 2. SENSORS (Room Prefix -> Temp Sensor Item)
// Maps the diverse naming conventions in your Items file to the standard Prefixes
val Map<String, String> roomSensors = newHashMap(
    "DEN" -> "Den_TstatTemp",      // Note: "Den" vs "DEN" handled here
    "MBa" -> "MBa_Tstat_Temp",
    "MBe" -> "MBe_Tstat_Temp",
    "LR"  -> "LR_Tstat_Temp",
    "GBr" -> "GBr_Tstat_Temp",
    "MR"  -> "MR_Tstat_Temp",
    "BMT" -> "BMT_Tstat_Temp",     // Assumes Main BMT Tstat. Switch to BMTBr_Tstat_Temp if needed.
    "GA"  -> "GA_Tstat_Temp",
    "KIT" -> "KITMS_Temp"          // Kitchen is usually slave, but good to have mapped
)

// =================================================================================
// RULE 1: UNIVERSAL THERMOSTAT LOGIC
// =================================================================================
rule "Universal Zone Manager"
when
    Member of gMS_Temps changed or
    Member of gHeating_Targets changed or
    Item System_Maintenance_Mode changed to OFF
then
    if (System_Maintenance_Mode.state == ON) return;

    // 1. IDENTIFY ROOM PREFIX
    val String triggerName = triggeringItem.name
    var String roomPrefix = ""

    // Strategy: Strip suffixes to find the "Root" name
    if (triggerName.contains("Heating_TargetTemp")) {
        roomPrefix = triggerName.split("_").get(0)
    } 
    else {
        // Handle the diverse Sensor naming conventions
        if (triggerName.contains("_Tstat_Temp")) {
            roomPrefix = triggerName.replace("_Tstat_Temp", "")
        } 
        else if (triggerName.contains("_TstatTemp")) {
            roomPrefix = triggerName.replace("_TstatTemp", "")
        }
        else if (triggerName.contains("MS_Temp")) {
            roomPrefix = triggerName.replace("MS_Temp", "")
        }
    }
    
    // Normalize "Den" to "DEN" (Case correction)
    if (roomPrefix == "Den") roomPrefix = "DEN"

    // Guard: Exit if this room isn't in our Actuator Map (e.g., Kitchen might be skipped here as it's a slave)
    if (roomPrefix == "" || !roomActuators.containsKey(roomPrefix)) return;

    // 2. LOOKUP ITEMS
    val String actuatorName = roomActuators.get(roomPrefix)
    val String tempItemName = roomSensors.get(roomPrefix)
    val String targetItemName = roomPrefix + "_Heating_TargetTemp"
    
    // Safety Check: Did we find a valid sensor map?
    if (tempItemName === null) {
        logWarn("Tstat.Error", "No sensor mapped for room: " + roomPrefix)
        return;
    }

    // Fetch Actual Item Objects
    val tempItem = ScriptServiceUtil.getItemRegistry.getItem(tempItemName)
    val targetItem = ScriptServiceUtil.getItemRegistry.getItem(targetItemName)
    val actuatorItem = ScriptServiceUtil.getItemRegistry.getItem(actuatorName)
    
    // UI Helper Item (Optional) - Used for Display
    var org.eclipse.smarthome.core.items.GenericItem uiTstatItem = null
    try {
        // Try the standard naming convention for UI item
        uiTstatItem = ScriptServiceUtil.getItemRegistry.getItem(roomPrefix + "_Tstat_Temp") as org.eclipse.smarthome.core.items.GenericItem
    } catch (Exception e) {
        // Special Case: "Den" prefix in UI items
        if (roomPrefix == "DEN") {
            try {
                uiTstatItem = ScriptServiceUtil.getItemRegistry.getItem("Den_TstatTemp") as org.eclipse.smarthome.core.items.GenericItem
            } catch (Exception e2) {}
        }
    }

    if (tempItem.state == NULL || targetItem.state == NULL) return;

    val double currentTemp = (tempItem.state as Number).doubleValue
    val double targetTemp = (targetItem.state as Number).doubleValue
    
    // Update UI (Safe)
    if (uiTstatItem !== null) {
        try { uiTstatItem.sendCommand(currentTemp) } catch(Exception e) {}
    }

    // 3. DETERMINE PARAMETERS (MASS-SPECIFIC LOGIC)
    // ---------------------------------------------------------
    var double hystHigh = 0.5
    var double hystLow = 0.5
    var boolean isRadiant = actuatorName.contains("RH")
    var String modeDescription = "Standard"

    if (isRadiant) {
        if (RH_HysteresisHigh.state instanceof Number) hystHigh = (RH_HysteresisHigh.state as Number).doubleValue
        if (RH_HysteresisLow.state instanceof Number) hystLow = (RH_HysteresisLow.state as Number).doubleValue
        
        // --- MASS-SPECIFIC CUTOFFS ---
        if (roomPrefix == "MBa" || roomPrefix == "KIT") {
            // High Mass (Concrete/Tile) -> Early Cutoff
            hystHigh = -0.2 
            modeDescription = "HighMass(EarlyCut)"
        } else {
            // Medium Mass (Wood) -> Soft Landing
            hystHigh = 0.0
            modeDescription = "MedMass(SoftLand)"
        }
        
    } else if (roomPrefix == "GA") {
         if (GA_HysteresisHigh.state instanceof Number) hystHigh = (GA_HysteresisHigh.state as Number).doubleValue
         if (GA_HysteresisLow.state instanceof Number) hystLow = (GA_HysteresisLow.state as Number).doubleValue
         modeDescription = "GarageUnit"
    } else {
        // Baseboard -> Standard Hysteresis
        if (ZV_HysteresisHigh.state instanceof Number) hystHigh = (ZV_HysteresisHigh.state as Number).doubleValue
        if (ZV_HysteresisLow.state instanceof Number) hystLow = (ZV_HysteresisLow.state as Number).doubleValue
        modeDescription = "Baseboard"
    }

    // SYNC BONUS ("Opportunity Heating")
    var double syncBonus = 0.0
    if (roomPrefix != "GA") { 
        if (Boiler_Graph_State.state instanceof Number) {
            var int bState = (Boiler_Graph_State.state as Number).intValue
            if (bState == 2 || bState > 0) syncBonus = 0.4
        }
    }

    // 4. DECISION LOGIC
    // ---------------------------------------------------------
    val double onThreshold = targetTemp - hystLow + syncBonus
    val double offThreshold = targetTemp + hystHigh 
    
    // DEBUGGING
    logInfo("Tstat.Debug", "EVAL: " + roomPrefix + 
        " | Cur=" + String::format("%.2f", currentTemp) + 
        " | Tgt=" + String::format("%.2f", targetTemp) + 
        " | Mode=" + modeDescription + 
        " | HystH=" + hystHigh + 
        " | Sync=" + syncBonus +
        " | ON_Trig=" + String::format("%.2f", onThreshold) + 
        " | OFF_Trig=" + String::format("%.2f", offThreshold)
    )

    // GARAGE OVERRIDE
    if (roomPrefix == "GA") {
        if (vGA_Heating_OFF_Override.state != ON) {
             if (actuatorItem.state != OFF) {
                 actuatorItem.sendCommand(OFF)
                 logInfo("Tstat.Debug", "   -> Override Active. Forcing OFF.")
             }
             return;
        }
    }

    // STATE MACHINE
    if (currentTemp < onThreshold) {
        // --- DEMAND: ON ---
        if (actuatorItem.state != ON) {
            actuatorItem.sendCommand(ON)
            lastOnTimes.put(actuatorName, now.millis)
            
            logInfo("Tstat.Action", 
                "Room:" + roomPrefix + 
                "|Act:ON" + 
                "|Cur:" + String::format("%.1f", currentTemp) + 
                "|Thresh:" + String::format("%.1f", onThreshold) +
                "|Mode:" + modeDescription
            )
        }
    }
    else if (currentTemp > offThreshold) {
        // --- DEMAND: OFF ---
        if (actuatorItem.state != OFF) {
            // Check Min Run Time
            var long lastOn = 0
            if (lastOnTimes.containsKey(actuatorName)) lastOn = lastOnTimes.get(actuatorName)
            var long runtime = now.millis - lastOn
            
            if (runtime > MIN_RUN_TIME || roomPrefix == "GA") { 
                actuatorItem.sendCommand(OFF)
                logInfo("Tstat.Action", 
                    "Room:" + roomPrefix + 
                    "|Act:OFF" + 
                    "|Cur:" + String::format("%.1f", currentTemp) + 
                    "|Thresh:" + String::format("%.1f", offThreshold) +
                    "|Mode:" + modeDescription
                )
            } else {
                 logInfo("Tstat.Debug", "   -> MinRunTime Active for " + roomPrefix + ". Remaining: " + ((MIN_RUN_TIME - runtime)/1000) + "s")
            }
        }
    } else {
        logInfo("Tstat.Debug", "   -> DEADBAND: No Action Required.") 
    }
end

// =================================================================================
// RULE 2: KITCHEN SLAVE (VARIABLE PWM)
// =================================================================================
rule "Kitchen Radiant Follower (Variable PWM)"
when
    Item DENRH changed or
    Time cron "0 0/15 * 1/1 * ? *" 
then
    if (System_Maintenance_Mode.state == ON) return;

    // USE MAPPED ITEMS FOR ROBUSTNESS
    // Explicitly fetching Items to ensure names match the map
    val tempItem = ScriptServiceUtil.getItemRegistry.getItem("Den_TstatTemp")
    val targetItem = ScriptServiceUtil.getItemRegistry.getItem("DEN_Heating_TargetTemp")
    
    if (DENRH.state == ON) {
        var double denError = 0.0
        if (targetItem.state instanceof Number && tempItem.state instanceof Number) {
            denError = (targetItem.state as Number).doubleValue - (tempItem.state as Number).doubleValue
        }
        
        var int onMinutes = 10 
        if (denError > 1.0) onMinutes = 30
        else if (denError > 0.5) onMinutes = 20
        
        var int currentMinute = now.getMinuteOfHour
        var int cycleMinute = currentMinute % 30
        
        if (cycleMinute < onMinutes) {
             if (KITRH.state != ON) {
                 KITRH.sendCommand(ON)
                 logInfo("Tstat.PWM", "Kitchen PWM: ON (Load: " + String::format("%.1f", denError) + "F | Duty:" + onMinutes + "m)")
             }
        } else {
             if (KITRH.state != OFF) {
                 KITRH.sendCommand(OFF)
                 logInfo("Tstat.PWM", "Kitchen PWM: OFF (Cycle Rest)")
             }
        }
    } else {
        if (KITRH.state != OFF) {
            KITRH.sendCommand(OFF)
            logInfo("Tstat.PWM", "Kitchen PWM: OFF (Den Satisfied)")
        }
    }
end

// =================================================================================
// RULE 3: PUMP & RELAY HAL (Hardware Abstraction Layer)
// =================================================================================

rule "CFH1 Manager"
when Item ZV changed then
    if (System_Maintenance_Mode.state == ON) return;
    if (ZV.state == ON && CFH1.state == OFF) {
        CFH1.sendCommand(ON)
        logInfo("HAL.Relay", "High Temp Call Active (CFH1 ON)")
    }
    else if (ZV.state == OFF && CFH1.state == ON) {
        CFH1.sendCommand(OFF)
        logInfo("HAL.Relay", "High Temp Call Satisfied (CFH1 OFF)")
    }
end

rule "CFH2 Manager"
when Item RHP changed then
    if (System_Maintenance_Mode.state == ON) return;
    if (RHP.state == ON && CFH2.state == OFF) {
        CFH2.sendCommand(ON)
        logInfo("HAL.Relay", "Radiant Call Active (CFH2 ON)")
    }
    else if (RHP.state == OFF && CFH2.state == ON) {
        CFH2.sendCommand(OFF)
        logInfo("HAL.Relay", "Radiant Call Satisfied (CFH2 OFF)")
    }
end

rule "Radiant Pump Logic"
when Item RHZV changed then
    if (System_Maintenance_Mode.state == ON) return;
    if (RHZV.state == ON) {
        if (RHP.state != ON) {
            logInfo("HAL.Pump", "Radiant Demand. Starting 2min Wax Valve Delay.")
            if (RHP_timer !== null) RHP_timer.cancel()
            RHP_timer = createTimer(now.plusMinutes(2), [|
                if (RHZV.state == ON) { 
                    RHP.sendCommand(ON)
                    logInfo("HAL.Pump", "Radiant Pump START")
                }
            ])
        }
    } else {
        if (RHP_timer !== null) RHP_timer.cancel()
        if (RHP.state != OFF) {
            RHP.sendCommand(OFF)
            logInfo("HAL.Pump", "Radiant Pump STOP")
        }
    }
end

rule "System Pump Logic"
when Item ZV changed then
    if (System_Maintenance_Mode.state == ON) return;
    if (ZV.state == ON) {
        if (SysPump.state != ON) {
            logInfo("HAL.Pump", "System Demand. Starting 1min Circ Delay.")
            if (SYSPump_timer !== null) SYSPump_timer.cancel()
            SYSPump_timer = createTimer(now.plusMinutes(1), [|
                if (ZV.state == ON) {
                    SysPump.sendCommand(ON)
                    logInfo("HAL.Pump", "System Pump START")
                }
            ])
        }
    } else {
        if (SYSPump_timer !== null) SYSPump_timer.cancel()
        if (SysPump.state != OFF) {
            SysPump.sendCommand(OFF)
            logInfo("HAL.Pump", "System Pump STOP")
        }
    }
end

// =================================================================================
// RULE 4: ERROR CALCULATION
// =================================================================================
rule "Calculate Max Room Error"
when
    Member of gMS_Temps changed or
    Member of gHeating_Targets changed or
    Time cron "0 * * ? * *"
then
    var double maxError = 0.0
    var String worstRoom = "None"
    
    // Explicitly iterate through KNOWN rooms to avoid parsing errors
    val rooms = newArrayList("DEN", "MBa", "MBe", "LR", "GBr", "MR", "BMT", "GA")
    
    rooms.forEach[ prefix |
        try {
            val String sName = roomSensors.get(prefix)
            val String tName = prefix + "_Heating_TargetTemp"
            
            if (sName !== null) {
                val sItem = ScriptServiceUtil.getItemRegistry.getItem(sName)
                val tItem = ScriptServiceUtil.getItemRegistry.getItem(tName)
                
                if (sItem.state instanceof Number && tItem.state instanceof Number) {
                    val double cVal = (sItem.state as Number).doubleValue
                    val double tVal = (tItem.state as Number).doubleValue
                    var double err = tVal - cVal
                    if (err > maxError) {
                        maxError = err
                        worstRoom = prefix
                    }
                }
            }
        } catch (Exception e) {}
    ]

    if (Boiler_Max_Error.state == NULL || (Boiler_Max_Error.state as Number).doubleValue != maxError) {
        Boiler_Max_Error.postUpdate(maxError)
        if (maxError > 0.5) logInfo("Boiler.Error", "Max Error: " + String::format("%.1f", maxError) + "F (" + worstRoom + ")")
    }
end