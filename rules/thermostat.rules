import org.eclipse.smarthome.model.script.ScriptServiceUtil
val String filename = "thermostat rules"
var Timer RHP_timer = null

// =================================================================================
// RELAY & PUMP LOGIC (LEGACY MODE ONLY)
// =================================================================================
// These rules only run if BMS Logic is DISABLED. 
// If BMS is ENABLED, the Lochinvar_BMS.rules file handles Pumps and ignores CFH Relays.

// --- CFH Rules ---

// CFH1 High Temp
rule "Call For High Heat"
when    
    Item ZV changed from OFF to ON 
then 
    // GUARD: Stop if Maintenance Mode is ON
    if (System_Maintenance_Mode.state == ON) return;
    // GUARD: Stop if BMS Mode is Active
    if (Boiler_BMS_ENBLE.state == ON) return;

    if (CFH1.state == OFF) {
        CFH1.sendCommand(ON)
        logInfo(filename, "High Temperature Call For Heat, Activating CFH1")     
    }
end

rule "CFH OFF"
when
    Item ZV changed from ON to OFF
then
    // GUARD: Stop if Maintenance Mode is ON
    if (System_Maintenance_Mode.state == ON) return;
    // GUARD: Stop if BMS Mode is Active
    if (Boiler_BMS_ENBLE.state == ON) return;

    if(CFH1.state == ON) {
        CFH1.sendCommand(OFF)
        logInfo(filename, "CFH Satisfied, Deactivating CFH1")
    }
end

// CFH2 Low temp radiant
rule "Call For Low Radiant Heat"
when    
    Item RHP changed from OFF to ON
then 
    // GUARD: Stop if Maintenance Mode is ON
    if (System_Maintenance_Mode.state == ON) return;
    // GUARD: Stop if BMS Mode is Active
    if (Boiler_BMS_ENBLE.state == ON) return;

    if (CFH2.state == OFF) {
        CFH2.sendCommand(ON)
        logInfo(filename, "Radiant Call For Heat, Activating CFH2")  
    }
end

rule "Call For Low Radiant Heat OFF"
when    
    Item RHP changed from ON to OFF
then 
    // GUARD: Stop if Maintenance Mode is ON
    if (System_Maintenance_Mode.state == ON) return;
    // GUARD: Stop if BMS Mode is Active
    if (Boiler_BMS_ENBLE.state == ON) return;

    if (CFH2.state == ON) {
        CFH2.sendCommand(OFF)
        logInfo(filename, "Radiant Call For Heat Ended, Deactivating CFH2")  
    }
end

// CFH3 High-Temp Unit Heater (Bypass)
rule "Call for High Heat Unit Heater ON"
when
    Item GAZV changed from OFF to ON
then
    // GUARD: Stop if Maintenance Mode is ON
    if (System_Maintenance_Mode.state == ON) return;

    if (CFH3.state != ON){
        CFH3.sendCommand(ON)
        logInfo("CFH3.rule", "High Temperature Call for heat required by Unit Heaters")
    }       
end

rule "Call for High Heat Unit Heater OFF"
when 
    Item GAZV changed from ON to OFF
then
    // GUARD: Stop if Maintenance Mode is ON
    if (System_Maintenance_Mode.state == ON) return;

    if (CFH3.state != OFF){
        CFH3.sendCommand(OFF)
        logInfo("CFH3.rule", "High Temperature Call for Heat satisfied, Turning off CFH3")
    }
end

// --- Pumping Rules ---

// Turn OFF Radiant Pump when radiant CFH=off
rule "Radiant Pump OFF"
when    
    Item RHZV changed from ON to OFF
then 
    // GUARD: Stop if Maintenance Mode is ON
    if (System_Maintenance_Mode.state == ON) return;
    // GUARD: Stop if BMS Mode is Active (BMS handles pumps)
    if (Boiler_BMS_ENBLE.state == ON) return;

    if(RHP.state == ON) {
        RHP.sendCommand(OFF)
        logInfo(filename, "RHP changed from on to off")
    }
end

// Turn ON Radiant Pump when CFH
rule "Radiant Pump ON"
when    
    Item RHZV changed from OFF to ON
then
    // GUARD: Stop if Maintenance Mode is ON
    if (System_Maintenance_Mode.state == ON) return;
    // GUARD: Stop if BMS Mode is Active
    if (Boiler_BMS_ENBLE.state == ON) return;

    logInfo(filename, "Radiant Heat Activated, Starting 1 minute pump delay")
    RHP_timer = (createTimer(now.plusMinutes(1))[
        logInfo(filename, "Delay over, RHP ON")
        RHP.sendCommand(ON) ]
    )
end

// Turn OFF System Pump when CFH=off
rule "System Pump OFF"
when    
    Item ZV changed from ON to OFF
then 
    // GUARD: Stop if Maintenance Mode is ON
    if (System_Maintenance_Mode.state == ON) return;
    // GUARD: Stop if BMS Mode is Active
    if (Boiler_BMS_ENBLE.state == ON) return;

    if(SysPump.state == ON) {
        SysPump.sendCommand(OFF)
        logInfo(filename, "SYS changed from on to off")
    }
end

// Turn ON System Pump when CFH
rule "System Pump ON"
when    
    Item ZV changed from OFF to ON
then
    // GUARD: Stop if Maintenance Mode is ON
    if (System_Maintenance_Mode.state == ON) return;
    // GUARD: Stop if BMS Mode is Active
    if (Boiler_BMS_ENBLE.state == ON) return;

    logInfo(filename, "System Heat Activated, Starting 1 minute pump delay")
    RHP_timer = (createTimer(now.plusMinutes(1))[
        logInfo(filename, "Delay over, System Pump ON")
        SysPump.sendCommand(ON) ]
    )
end


// =================================================================================
// THERMOSTAT LOGIC (ALWAYS ACTIVE)
// =================================================================================
// These rules MUST remain active in all modes to update the UI (Virtual Tstat).
// However, the ACTUATION (Sending Commands to Valves) is blocked in Maintenance Mode.

//Radiant Rules

rule "DEN Radiant CFH Thermostat"
    when
        Item DEN_Heating_TargetTemp changed or
        Item DENMS_Temp changed or
        Item System_Maintenance_Mode changed to OFF
    then
        var temperature = (DENMS_Temp.state as Number).doubleValue
        var setpoint = (DEN_Heating_TargetTemp.state as Number).doubleValue
        var hysteresisHigh = (RH_HysteresisHigh.state as Number).doubleValue
        var hysteresisLow = (RH_HysteresisLow.state as Number).doubleValue

        // 1. UPDATE VIRTUAL THERMOSTAT (Visuals)
        // We do this BEFORE checking Maintenance Mode so the UI stays alive.
        sendCommand(Den_TstatTemp, temperature)
        
        // 2. CHECK MAINTENANCE GUARD
        if (System_Maintenance_Mode.state == ON) return;

        // 3. ACTUATION LOGIC
        if (temperature < (setpoint - hysteresisLow)) {
            if (DENRH.state != ON) {
                sendCommand(DENRH, ON)
                //Send command for Kitchen while there is no kitchen thermostat sensor
                sendCommand(KITRH,ON)
            }
        }   
        else if (temperature > (setpoint + hysteresisHigh)) {
            if (DENRH.state != OFF) {
                sendCommand(DENRH, OFF) 
                //Send command for Kitchen while there is no kitchen thermostat sensor
                sendCommand(KITRH,OFF)
            }   
        }
end         

rule "Master Bath Radiant Thermostat"
    when
        Item MBe_Heating_TargetTemp changed or
        Item MBeMS_Temp changed or
        Item System_Maintenance_Mode changed to OFF
    then
        var temperature = (MBeMS_Temp.state as Number).doubleValue
        var setpoint = (MBe_Heating_TargetTemp.state as Number).doubleValue
        var hysteresisHigh = (RH_HysteresisHigh.state as Number).doubleValue
        var hysteresisLow = (RH_HysteresisLow.state as Number).doubleValue
        
        // 1. UPDATE VIRTUAL THERMOSTAT
        sendCommand(MBa_Tstat_Temp, temperature)

        // 2. CHECK MAINTENANCE GUARD
        if (System_Maintenance_Mode.state == ON) return;

        // 3. ACTUATION LOGIC
        if (temperature < (setpoint - hysteresisLow)) {
            if (MBaRH.state != ON) {
                sendCommand(MBaRH, ON)
            }
        }   
        else if (temperature > (setpoint + hysteresisHigh)) {
            if (MBaRH.state != OFF) {
                sendCommand(MBaRH, OFF)
            }   
        }
end     

rule "Master Bedroom Radiant Thermostat"
    when
        Item MBe_Heating_TargetTemp changed or
        Item MBeMS_Temp changed or
        Item System_Maintenance_Mode changed to OFF
    then
        var temperature = (MBeMS_Temp.state as Number).doubleValue
        var setpoint = (MBe_Heating_TargetTemp.state as Number).doubleValue
        var hysteresisHigh = (RH_HysteresisHigh.state as Number).doubleValue
        var hysteresisLow = (RH_HysteresisLow.state as Number).doubleValue

        // 1. UPDATE VIRTUAL THERMOSTAT
        sendCommand(MBe_Tstat_Temp, temperature)
    
        // 2. CHECK MAINTENANCE GUARD
        if (System_Maintenance_Mode.state == ON) return;

        // 3. ACTUATION LOGIC
        if (temperature < (setpoint - hysteresisLow)) {
            if (MBeRH.state != ON) {
                sendCommand(MBeRH, ON)
            }
        }   
        else if (temperature > (setpoint + hysteresisHigh)) {
            if (MBeRH.state != OFF) {
                sendCommand(MBeRH, OFF)
            }   
        }
end     
    
// High Temp Rules

rule "Living Room CFH Thermostat"
    when
        Item LR_Heating_TargetTemp changed or
        Item LRMS_Temp changed or
        Item System_Maintenance_Mode changed to OFF
    then
        var temperature = (LRMS_Temp.state as Number).doubleValue
        var setpoint = (LR_Heating_TargetTemp.state as Number).doubleValue
        var hysteresisHigh = (ZV_HysteresisHigh.state as Number).doubleValue
        var hysteresisLow = (ZV_HysteresisLow.state as Number).doubleValue
        
        // 1. UPDATE VIRTUAL THERMOSTAT
        sendCommand(LR_Tstat_Temp, temperature)
    
        // 2. CHECK MAINTENANCE GUARD
        if (System_Maintenance_Mode.state == ON) return;

        // 3. ACTUATION LOGIC
        if (temperature < (setpoint - hysteresisLow)) {
            if (LRZV.state != ON) {
                sendCommand(LRZV, ON)
            }
        }   
        else if (temperature > (setpoint + hysteresisHigh)) {
            if (LRZV.state != OFF) {
                sendCommand(LRZV, OFF) 
            }   
        }
end         

rule "Guest BedRoom CFH Thermostat"
    when
        Item GBr_Heating_TargetTemp changed or
        Item GBrMS_Temp changed or
        Item System_Maintenance_Mode changed to OFF
    then
        var temperature = (GBrMS_Temp.state as Number).doubleValue
        var setpoint = (GBr_Heating_TargetTemp.state as Number).doubleValue
        var hysteresisHigh = (ZV_HysteresisHigh.state as Number).doubleValue
        var hysteresisLow = (ZV_HysteresisLow.state as Number).doubleValue
        
        // 1. UPDATE VIRTUAL THERMOSTAT
        sendCommand(GBr_Tstat_Temp, temperature)

        // 2. CHECK MAINTENANCE GUARD
        if (System_Maintenance_Mode.state == ON) return;

        // 3. ACTUATION LOGIC
        if (temperature < (setpoint - hysteresisLow)) {
            if (GBrZV.state != ON) {
                sendCommand(GBrZV, ON)
            }
        }   
        else if (temperature > (setpoint + hysteresisHigh)) {
            if (GBrZV.state != OFF) {
                sendCommand(GBrZV, OFF)
            }   
        }
end          

rule "MudRoom CFH Thermostat"
    when
        Item MR_Heating_TargetTemp changed or
        Item MRMS_Temp changed or
        Item System_Maintenance_Mode changed to OFF
    then
        var temperature = (MRMS_Temp.state as Number).doubleValue
        var setpoint = (MR_Heating_TargetTemp.state as Number).doubleValue
        var hysteresisHigh = (ZV_HysteresisHigh.state as Number).doubleValue
        var hysteresisLow = (ZV_HysteresisLow.state as Number).doubleValue

        // 1. UPDATE VIRTUAL THERMOSTAT
        sendCommand(MR_Tstat_Temp, temperature)
    
        // 2. CHECK MAINTENANCE GUARD
        if (System_Maintenance_Mode.state == ON) return;

        // 3. ACTUATION LOGIC
        if (temperature < (setpoint - hysteresisLow)) {
            if (MRZV.state != ON) {
                sendCommand(MRZV, ON)
            }
        }   
        else if (temperature > (setpoint + hysteresisHigh)) {
            if (MRZV.state != OFF) {
                sendCommand(MRZV, OFF)
            }   
        }
end     

rule "Basement CFH Thermostat"
    when
        Item BMT_Heating_TargetTemp changed or
        Item BMTBrMS_Temp changed or
        Item System_Maintenance_Mode changed to OFF
    then
        var temperature = (BMTBrMS_Temp.state as Number).doubleValue
        var setpoint = (BMT_Heating_TargetTemp.state as Number).doubleValue
        var hysteresisHigh = (ZV_HysteresisHigh.state as Number).doubleValue
        var hysteresisLow = (ZV_HysteresisLow.state as Number).doubleValue

        // 1. UPDATE VIRTUAL THERMOSTAT
        sendCommand(BMT_Tstat_Temp, temperature)
    
        // 2. CHECK MAINTENANCE GUARD
        if (System_Maintenance_Mode.state == ON) return;

        // 3. ACTUATION LOGIC
        if (temperature < (setpoint - hysteresisLow)) {
            if (BMTZV.state != ON) {
                sendCommand(BMTZV, ON)
            }
        }   
        else if (temperature > (setpoint + hysteresisHigh)) {
            if (BMTZV.state != OFF) {
                sendCommand(BMTZV, OFF)
            }   
        }   
end         

rule "Garage CFH Thermostat"
    when
        Item GA_Heating_TargetTemp changed or
        Item GAMS_Temp changed or
        Item vGA_Heating_OFF_Override changed from OFF to ON or
        Item System_Maintenance_Mode changed to OFF

    then
        var temperature = (GAMS_Temp.state as Number).doubleValue
        var setpoint = (GA_Heating_TargetTemp.state as Number).doubleValue
        var hysteresisHigh = (GA_HysteresisHigh.state as Number).doubleValue
        var hysteresisLow = (GA_HysteresisLow.state as Number).doubleValue
        
        // 1. UPDATE VIRTUAL THERMOSTAT
        sendCommand(GA_Tstat_Temp, temperature)

        // 2. CHECK MAINTENANCE GUARD
        if (System_Maintenance_Mode.state == ON) return;

        // 3. ACTUATION LOGIC
        if (vGA_Heating_OFF_Override.state == ON){
            if (temperature < (setpoint - hysteresisLow)) {
                if (GAZV.state != ON) {
                    sendCommand(GAZV, ON)
                }
            }   
            else if (temperature > (setpoint + hysteresisHigh)) {
                if (GAZV.state != OFF) {
                    sendCommand(GAZV, OFF)
                }   
            }   
        }    
        else if (vGA_Heating_OFF_Override.state == NULL) {
            sendCommand(vGA_Heating_OFF_Override, OFF)
        }
end

rule "Garage Overide OFF turns Off Garage Zone Valve "
    when
        Item vGA_Heating_OFF_Override changed from ON to OFF
    then
        // GUARD: Stop if Maintenance Mode is ON
        if (System_Maintenance_Mode.state == ON) return;

        if (GAZV.state== ON){
            sendCommand(GAZV, OFF)
        }
end
rule "Calculate Max Room Error"
when
    // Trigger whenever any temp or target changes
    Member of gMS_Temps changed or
    Member of gHeating_Targets changed or
    Time cron "0 * * ? * *"
then
    var Double maxError = 0.0
    var String worstRoom = "None"

    // List of Room Prefixes to check
    // Ensure these match your item naming convention: [Prefix]MS_Temp and [Prefix]_Heating_TargetTemp
    val rooms = newArrayList("DEN", "LR", "KIT", "GBr", "MR", "BMT", "MBe", "MBa")

    rooms.forEach[ room |
        val tempItem = ScriptServiceUtil.getItemRegistry.getItem(room + "MS_Temp")
        val targetItem = ScriptServiceUtil.getItemRegistry.getItem(room + "_Heating_TargetTemp")

        if (tempItem.state instanceof Number && targetItem.state instanceof Number) {
            val Double currentTemp = (tempItem.state as Number).doubleValue
            val Double targetTemp = (targetItem.state as Number).doubleValue
            
            // Calculate Error (Positive means too cold)
            var Double error = targetTemp - currentTemp
            
            // Ignore negative error (room is too hot)
            if (error < 0) error = 0.0

            if (error > maxError) {
                maxError = error
                worstRoom = room
            }
        }
    ]

    // Post the result
    if (Boiler_Max_Error.state != maxError) {
        Boiler_Max_Error.postUpdate(maxError)
        logInfo("Boiler.ErrorCalc", "New Max Error: " + maxError + "Â°F in " + worstRoom)
    }
end