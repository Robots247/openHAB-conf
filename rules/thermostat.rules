import org.eclipse.smarthome.model.script.ScriptServiceUtil
import java.util.Map

// ===================================================================================
// PROFESSIONAL THERMOSTAT ENGINE (Universal State Machine)
// Architecture: Group-Based Triggers + Periodic Watchdog
// Updates: Added "Watchdog Enforcer" to prevent frozen zones
// Compatibility: OpenHAB 2.5 (Eclipse Smarthome)
// ===================================================================================

// --- GLOBAL VARIABLES ---
val String filename = "Thermostat.Engine"
var Timer RHP_timer = null
var Timer SYSPump_timer = null

// Runtime Tracking Map
val Map<String, Long> lastOnTimes = newHashMap

// CONFIGURATION
val long MIN_RUN_TIME = 900000 // 15 Minutes (Wax Valve Protection)

// --- MAPPING CONFIGURATION ---

// 1. ACTUATORS (Room Prefix -> Switch Item)
val Map<String, String> roomActuators = newHashMap(
    "DEN" -> "DENRH",
    "MBa" -> "MBaRH",
    "MBe" -> "MBeRH",
    "LR"  -> "LRZV",
    "GBr" -> "GBrZV",
    "MR"  -> "MRZV",
    "BMT" -> "BMTZV",
    "GA"  -> "GAZV"
)

// 2. SENSORS (Room Prefix -> Temp Sensor Item)
val Map<String, String> roomSensors = newHashMap(
    "DEN" -> "Den_TstatTemp",      
    "MBa" -> "MBa_Tstat_Temp",
    "MBe" -> "MBe_Tstat_Temp",
    "LR"  -> "LR_Tstat_Temp",
    "GBr" -> "GBr_Tstat_Temp",
    "MR"  -> "MR_Tstat_Temp",
    "BMT" -> "BMT_Tstat_Temp",     
    "GA"  -> "GA_Tstat_Temp",
    "KIT" -> "KITMS_Temp"          
)

// =================================================================================
// RULE 1: UNIVERSAL ZONE MANAGER (Event Driven)
// =================================================================================
rule "Universal Zone Manager"
when
    Member of gMS_Temps changed or
    Member of gHeating_Targets changed or
    Item System_Maintenance_Mode changed to OFF
then
    if (System_Maintenance_Mode.state == ON) return;

    // 1. IDENTIFY ROOM & ITEMS
    val String triggerName = triggeringItem.name
    var String roomPrefix = ""

    if (triggerName.contains("Heating_TargetTemp")) {
        roomPrefix = triggerName.split("_").get(0)
    } else {
        if (triggerName.contains("_Tstat_Temp")) roomPrefix = triggerName.replace("_Tstat_Temp", "")
        else if (triggerName.contains("_TstatTemp")) roomPrefix = triggerName.replace("_TstatTemp", "")
        else if (triggerName.contains("MS_Temp")) roomPrefix = triggerName.replace("MS_Temp", "")
    }
    
    if (roomPrefix == "Den") roomPrefix = "DEN"
    if (roomPrefix == "" || !roomActuators.containsKey(roomPrefix)) return;

    // Execute Logic for this single room
    checkZoneState(roomPrefix)
end

// =================================================================================
// RULE 1.5: THE WATCHDOG ENFORCER (Periodic Audit)
// =================================================================================
// SAFETY NET: Runs every 5 minutes to catch "Missed" commands or Stuck Valves.
// This prevents a room from freezing if the "Changed" event was missed.

rule "Thermostat Watchdog Enforcer"
when
    Time cron "0 0/5 * * * ?" 
then
    if (System_Maintenance_Mode.state == ON) return;
    
    // Iterate through ALL known rooms and force a state check
    roomActuators.keySet.forEach[ room |
        checkZoneState(room)
    ]
end

// =================================================================================
// HELPER LAMBDA: CORE LOGIC (Reused by Event & Watchdog)
// =================================================================================
// By moving the logic here, we ensure the Watchdog and the Event Trigger use
// IDENTICAL decision making.

val org.eclipse.xtext.xbase.lib.Procedures$Procedure1<String> checkZoneState = [ String roomPrefix |
    
    // 1. LOOKUP ITEMS
    val String actuatorName = roomActuators.get(roomPrefix)
    val String tempItemName = roomSensors.get(roomPrefix)
    val String targetItemName = roomPrefix + "_Heating_TargetTemp"
    
    if (tempItemName === null) return;

    val tempItem = ScriptServiceUtil.getItemRegistry.getItem(tempItemName)
    val targetItem = ScriptServiceUtil.getItemRegistry.getItem(targetItemName)
    val actuatorItem = ScriptServiceUtil.getItemRegistry.getItem(actuatorName)
    
    // UI Helper Item (Optional)
    var org.eclipse.smarthome.core.items.GenericItem uiTstatItem = null
    try {
        uiTstatItem = ScriptServiceUtil.getItemRegistry.getItem(roomPrefix + "_Tstat_Temp") as org.eclipse.smarthome.core.items.GenericItem
    } catch (Exception e) {
        if (roomPrefix == "DEN") {
            try { uiTstatItem = ScriptServiceUtil.getItemRegistry.getItem("Den_TstatTemp") as org.eclipse.smarthome.core.items.GenericItem } catch (Exception e2) {}
        }
    }

    if (tempItem.state == NULL || targetItem.state == NULL) return;

    val double currentTemp = (tempItem.state as Number).doubleValue
    val double targetTemp = (targetItem.state as Number).doubleValue
    
    if (uiTstatItem !== null) { try { uiTstatItem.sendCommand(currentTemp) } catch(Exception e) {} }

    // 2. DETERMINE PARAMETERS
    var double hystHigh = 0.5
    var double hystLow = 0.5
    var boolean isRadiant = actuatorName.contains("RH")
    var String modeDescription = "Standard"

    if (isRadiant) {
        if (RH_HysteresisHigh.state instanceof Number) hystHigh = (RH_HysteresisHigh.state as Number).doubleValue
        if (RH_HysteresisLow.state instanceof Number) hystLow = (RH_HysteresisLow.state as Number).doubleValue
        
        if (roomPrefix == "MBa" || roomPrefix == "KIT") {
            hystHigh = -0.2 
            modeDescription = "HighMass(EarlyCut)"
        } else {
            hystHigh = 0.0
            modeDescription = "MedMass(SoftLand)"
        }
    } else if (roomPrefix == "GA") {
         if (GA_HysteresisHigh.state instanceof Number) hystHigh = (GA_HysteresisHigh.state as Number).doubleValue
         if (GA_HysteresisLow.state instanceof Number) hystLow = (GA_HysteresisLow.state as Number).doubleValue
         modeDescription = "GarageUnit"
    } else {
        if (ZV_HysteresisHigh.state instanceof Number) hystHigh = (ZV_HysteresisHigh.state as Number).doubleValue
        if (ZV_HysteresisLow.state instanceof Number) hystLow = (ZV_HysteresisLow.state as Number).doubleValue
        modeDescription = "Baseboard"
    }

    // SYNC BONUS
    var double syncBonus = 0.0
    if (roomPrefix != "GA") { 
        if (Boiler_Graph_State.state instanceof Number) {
            var int bState = (Boiler_Graph_State.state as Number).intValue
            if (bState == 2 || bState > 0) syncBonus = 0.4
        }
    }

    // 3. DECISION LOGIC
    val double onThreshold = targetTemp - hystLow + syncBonus
    val double offThreshold = targetTemp + hystHigh 
    
    // GARAGE OVERRIDE
    if (roomPrefix == "GA") {
        if (vGA_Heating_OFF_Override.state != ON) {
             if (actuatorItem.state != OFF) {
                 actuatorItem.sendCommand(OFF)
                 logInfo("Tstat.Watchdog", "Garage Override Active. Forcing GAZV OFF.")
             }
             return;
        }
    }

    // STATE MACHINE
    if (currentTemp < onThreshold) {
        // --- DEMAND: ON ---
        // WATCHDOG FIX: We check if it is NOT ON. 
        // If it SHOULD be on, but is OFF, we force it.
        if (actuatorItem.state != ON) {
            actuatorItem.sendCommand(ON)
            lastOnTimes.put(actuatorName, now.millis)
            
            logInfo("Tstat.Action", 
                "Room:" + roomPrefix + 
                "|Act:ON" + 
                "|Cur:" + String::format("%.1f", currentTemp) + 
                "|Thresh:" + String::format("%.1f", onThreshold) +
                "|Mode:" + modeDescription
            )
        }
    }
    else if (currentTemp > offThreshold) {
        // --- DEMAND: OFF ---
        if (actuatorItem.state != OFF) {
            // Check Min Run Time
            var long lastOn = 0
            if (lastOnTimes.containsKey(actuatorName)) lastOn = lastOnTimes.get(actuatorName)
            var long runtime = now.millis - lastOn
            
            if (runtime > MIN_RUN_TIME || roomPrefix == "GA") { 
                actuatorItem.sendCommand(OFF)
                logInfo("Tstat.Action", 
                    "Room:" + roomPrefix + 
                    "|Act:OFF" + 
                    "|Cur:" + String::format("%.1f", currentTemp) + 
                    "|Thresh:" + String::format("%.1f", offThreshold) +
                    "|Mode:" + modeDescription
                )
            } else {
                 // Log only on change or explicit debug
            }
        }
    }
]

// =================================================================================
// RULE 2: KITCHEN SLAVE (VARIABLE PWM)
// =================================================================================
rule "Kitchen Radiant Follower (Variable PWM)"
when
    Item DENRH changed or
    Time cron "0 0/15 * 1/1 * ? *" 
then
    if (System_Maintenance_Mode.state == ON) return;

    val tempItem = ScriptServiceUtil.getItemRegistry.getItem("Den_TstatTemp")
    val targetItem = ScriptServiceUtil.getItemRegistry.getItem("DEN_Heating_TargetTemp")
    
    if (DENRH.state == ON) {
        var double denError = 0.0
        if (targetItem.state instanceof Number && tempItem.state instanceof Number) {
            denError = (targetItem.state as Number).doubleValue - (tempItem.state as Number).doubleValue
        }
        
        var int onMinutes = 10 
        if (denError > 1.0) onMinutes = 30
        else if (denError > 0.5) onMinutes = 20
        
        var int currentMinute = now.getMinuteOfHour
        var int cycleMinute = currentMinute % 30
        
        if (cycleMinute < onMinutes) {
             if (KITRH.state != ON) {
                 KITRH.sendCommand(ON)
                 logInfo("Tstat.PWM", "Kitchen PWM: ON (Load: " + String::format("%.1f", denError) + "F | Duty:" + onMinutes + "m)")
             }
        } else {
             if (KITRH.state != OFF) {
                 KITRH.sendCommand(OFF)
                 logInfo("Tstat.PWM", "Kitchen PWM: OFF (Cycle Rest)")
             }
        }
    } else {
        if (KITRH.state != OFF) {
            KITRH.sendCommand(OFF)
            logInfo("Tstat.PWM", "Kitchen PWM: OFF (Den Satisfied)")
        }
    }
end

// =================================================================================
// RULE 3: PUMP & RELAY HAL (Hardware Abstraction Layer)
// =================================================================================

rule "CFH1 Manager"
when Item ZV changed or Time cron "0 0/5 * * * ?" then
    if (System_Maintenance_Mode.state == ON) return;
    if (ZV.state == ON && CFH1.state == OFF) {
        CFH1.sendCommand(ON)
        logInfo("HAL.Watchdog", "Re-asserting CFH1 (High Temp) ON")
    }
    else if (ZV.state == OFF && CFH1.state == ON) {
        CFH1.sendCommand(OFF)
    }
end

rule "CFH2 Manager"
when Item RHP changed or Time cron "0 0/5 * * * ?" then
    if (System_Maintenance_Mode.state == ON) return;
    if (RHP.state == ON && CFH2.state == OFF) {
        CFH2.sendCommand(ON)
        logInfo("HAL.Watchdog", "Re-asserting CFH2 (Radiant) ON")
    }
    else if (RHP.state == OFF && CFH2.state == ON) {
        CFH2.sendCommand(OFF)
    }
end

rule "Radiant Pump Logic"
when Item RHZV changed or Time cron "0 0/5 * * * ?" then
    if (System_Maintenance_Mode.state == ON) return;
    if (RHZV.state == ON) {
        if (RHP.state != ON) {
            // Check if we are waiting on a timer
            if (RHP_timer === null) {
                 // No timer running, but pump is OFF? Restart Delay.
                 logInfo("HAL.Watchdog", "Radiant Demand Active but Pump OFF. Starting Delay.")
                 RHP_timer = createTimer(now.plusMinutes(2), [|
                    if (RHZV.state == ON) { 
                        RHP.sendCommand(ON)
                        logInfo("HAL.Pump", "Radiant Pump START")
                    }
                ])
            }
        }
    } else {
        if (RHP.state != OFF) RHP.sendCommand(OFF)
    }
end

rule "System Pump Logic"
when Item ZV changed or Time cron "0 0/5 * * * ?" then
    if (System_Maintenance_Mode.state == ON) return;
    if (ZV.state == ON) {
        if (SysPump.state != ON) {
            if (SYSPump_timer === null) {
                logInfo("HAL.Watchdog", "System Demand Active but Pump OFF. Starting Delay.")
                SYSPump_timer = createTimer(now.plusMinutes(1), [|
                    if (ZV.state == ON) {
                        SysPump.sendCommand(ON)
                        logInfo("HAL.Pump", "System Pump START")
                    }
                ])
            }
        }
    } else {
        if (SysPump.state != OFF) SysPump.sendCommand(OFF)
    }
end

// =================================================================================
// RULE 4: ERROR CALCULATION
// =================================================================================
rule "Calculate Max Room Error"
when
    Member of gMS_Temps changed or
    Member of gHeating_Targets changed or
    Time cron "0 * * ? * *"
then
    var double maxError = 0.0
    var String worstRoom = "None"
    
    val rooms = newArrayList("DEN", "MBa", "MBe", "LR", "GBr", "MR", "BMT", "GA")
    
    rooms.forEach[ prefix |
        try {
            val String sName = roomSensors.get(prefix)
            val String tName = prefix + "_Heating_TargetTemp"
            
            if (sName !== null) {
                val sItem = ScriptServiceUtil.getItemRegistry.getItem(sName)
                val tItem = ScriptServiceUtil.getItemRegistry.getItem(tName)
                
                if (sItem.state instanceof Number && tItem.state instanceof Number) {
                    val double cVal = (sItem.state as Number).doubleValue
                    val double tVal = (tItem.state as Number).doubleValue
                    var double err = tVal - cVal
                    if (err > maxError) {
                        maxError = err
                        worstRoom = prefix
                    }
                }
            }
        } catch (Exception e) {}
    ]

    if (Boiler_Max_Error.state == NULL || (Boiler_Max_Error.state as Number).doubleValue != maxError) {
        Boiler_Max_Error.postUpdate(maxError)
        if (maxError > 0.5) logInfo("Boiler.Error", "Max Error: " + String::format("%.1f", maxError) + "F (" + worstRoom + ")")
    }
end